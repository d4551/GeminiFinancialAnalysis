{"files":[{"id":"a316cc87-3669-4877-865c-839c2db7d419","name":"appsscript","type":"json","source":"{\n  \"timeZone\": \"Europe/Berlin\",\n  \"dependencies\": {\n    \"enabledAdvancedServices\": [\n      {\n        \"userSymbol\": \"Drive\",\n        \"version\": \"v2\",\n        \"serviceId\": \"drive\"\n      },\n      {\n        \"userSymbol\": \"Docs\",\n        \"version\": \"v1\",\n        \"serviceId\": \"docs\"\n      },\n      {\n        \"userSymbol\": \"Sheets\",\n        \"version\": \"v4\",\n        \"serviceId\": \"sheets\"\n      }\n    ]\n  },\n  \"exceptionLogging\": \"STACKDRIVER\",\n  \"runtimeVersion\": \"V8\",\n  \"oauthScopes\": [\n    \"https://www.googleapis.com/auth/script.external_request\",\n    \"https://www.googleapis.com/auth/script.scriptapp\",\n    \"https://www.googleapis.com/auth/spreadsheets\",\n    \"https://www.googleapis.com/auth/drive.file\",\n    \"https://www.googleapis.com/auth/documents\",\n    \"https://www.googleapis.com/auth/drive\",\n    \"https://www.googleapis.com/auth/script.container.ui\"\n  ],\n  \"webapp\": {\n    \"executeAs\": \"USER_ACCESSING\",\n    \"access\": \"ANYONE\"\n  }\n}"},{"id":"72c85fb5-59bd-4300-9935-fc4b1dc2841e","name":"anomolyDetection","type":"server_js","source":"/**\n * Global/base configuration for anomaly detection.\n *\n * You can override any of these settings by passing a custom config object to\n * detectAnomalies(sheet, userConfig). The function will merge your overrides\n * into this base config, allowing you to dynamically handle categories, detection\n * algorithms, outlier methods, etc.\n */\nconst config \u003d {\n  amount: {\n    min: 0,\n    max: 10000,\n    allowNegative: false // Allow/disallow negative amounts\n  },\n  date: {\n    // Multiple patterns allow flexible input formats\n    datePatterns: [\n      /^\\d{4}-\\d{2}-\\d{2}$/, // e.g., 2023-05-15\n      /^\\d{2}\\/\\d{2}\\/\\d{4}$/ // e.g., 05/15/2023\n    ],\n    allowFuture: false // Allow/disallow future dates\n  },\n  description: {\n    required: true\n  },\n  category: {\n    required: true,\n    validCategories: [\u0027Sales\u0027, \u0027Marketing\u0027, \u0027Development\u0027, \u0027HR\u0027] // Example categories\n  },\n  email: {\n    required: false,\n    format: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/ // Simple email regex validation\n  },\n  outliers: {\n    check: true,\n    threshold: 3,\n    /**\n     * method can be one of:\n     * - \u0027zscore\u0027: standard z-score method (threshold x standard deviations from mean)\n     * - \u0027iqr\u0027: interquartile range method (outliers are outside [Q1 - factor*(Q3-Q1), Q3 + factor*(Q3-Q1)])\n     * - \u0027none\u0027: skip outlier detection\n     */\n    method: \u0027zscore\u0027,\n    iqrFactor: 1.5 // The typical factor used for IQR method if outliers.method \u003d \u0027iqr\u0027\n  },\n  duplicates: {\n    check: true,\n    uniqueColumns: [\u0027amount\u0027, \u0027date\u0027, \u0027description\u0027] // Columns used to check for duplicates\n  },\n  mandatoryFields: [\u0027amount\u0027, \u0027date\u0027, \u0027description\u0027, \u0027category\u0027], // Required columns\n\n  // Toggle AI-based anomaly detection\n  enableAIDetection: true,\n\n  // Attempt to infer column types by scanning row data\n  dynamicCheck: true,\n\n  /**\n   * detectionAlgorithm can be any label recognized by your system:\n   *   - \u0027standard\u0027 (only traditional checks)\n   *   - \u0027ai\u0027 (only AI checks)\n   *   - \u0027hybrid\u0027 (both)\n   *   - \u0027none\u0027 (skip all checks)\n   *   - etc.\n   */\n  detectionAlgorithm: \u0027standard\u0027\n};\n\n/**\n * Merge user-provided config overrides into the base config object.\n * Performs a shallow merge for top-level and direct sub-level fields.\n *\n * @param {Object} baseConfig - The default/base config object.\n * @param {Object} overrides - An object of overrides to merge on top of baseConfig.\n * @returns {Object} - A new config object with merged values.\n */\nfunction getMergedConfig(baseConfig, overrides) {\n  if (!overrides || typeof overrides !\u003d\u003d \u0027object\u0027) {\n    return JSON.parse(JSON.stringify(baseConfig)); // Return a clone of the baseConfig\n  }\n  const merged \u003d JSON.parse(JSON.stringify(baseConfig)); // Clone baseConfig to avoid mutating it\n\n  for (const key in overrides) {\n    if (!overrides.hasOwnProperty(key)) continue;\n\n    // If base config has the same key as an object, and overrides[key] is also an object,\n    // we do a shallow merge of that sub-object. Otherwise, we overwrite.\n    if (\n      merged[key] \u0026\u0026\n      typeof merged[key] \u003d\u003d\u003d \u0027object\u0027 \u0026\u0026\n      !Array.isArray(merged[key]) \u0026\u0026\n      typeof overrides[key] \u003d\u003d\u003d \u0027object\u0027 \u0026\u0026\n      !Array.isArray(overrides[key])\n    ) {\n      merged[key] \u003d Object.assign({}, merged[key], overrides[key]);\n    } else {\n      merged[key] \u003d overrides[key];\n    }\n  }\n\n  return merged;\n}\n\n/**\n * Main function to detect anomalies in the spreadsheet using:\n * - Traditional checks (data validation, duplicates, outliers, etc.)\n * - Optional AI-based anomaly detection (if enabled in config)\n * - Dynamic or user-defined detection algorithms\n *\n * @param {Sheet} sheet - The Google Sheets sheet to analyze.\n * @param {Object} userConfig - Optional overrides for the base config.\n * @returns {Array} - An array of detected anomalies.\n */\nfunction detectAnomalies(sheet, userConfig) {\n  const localConfig \u003d getMergedConfig(config, userConfig);\n\n  if (!sheet) {\n    logError(\u0027Sheet is undefined or not provided.\u0027);\n    return [];\n  }\n\n  // Check if detectionAlgorithm is \u0027none\u0027 or otherwise set to skip\n  if (localConfig.detectionAlgorithm.toLowerCase() \u003d\u003d\u003d \u0027none\u0027) {\n    logMessage(\u0027Detection algorithm set to \"none\". Skipping all anomaly checks.\u0027);\n    return [];\n  }\n\n  const dataRange \u003d sheet.getDataRange();\n  const data \u003d dataRange.getValues();\n  if (data.length \u003c 2) {\n    logError(\u0027Sheet contains no data or only headers.\u0027);\n    return [];\n  }\n\n  // Normalize headers to lowercase\n  const rawHeaders \u003d data[0];\n  const headers \u003d rawHeaders.map(h \u003d\u003e (h || \u0027\u0027).toString().toLowerCase());\n\n  // Validate mandatory fields (if found in headers)\n  for (const field of localConfig.mandatoryFields) {\n    if (!headers.includes(field.toLowerCase())) {\n      logError(`Mandatory field \"${field}\" not found in headers.`);\n      // Optionally, you could return [] or continue. We\u0027ll log an error and continue.\n    }\n  }\n\n  // If dynamicCheck is enabled, attempt to infer column usage from sample data\n  let inferredColumns \u003d {};\n  if (localConfig.dynamicCheck) {\n    inferredColumns \u003d inferColumnTypes(headers, data);\n    logMessage(`Dynamically inferred columns: ${JSON.stringify(inferredColumns)}`);\n  }\n\n  // We accumulate anomalies in this array\n  const anomalies \u003d [];\n  // Keep track of duplicate entries using a set\n  const seenEntries \u003d new Set();\n  // Track amounts for outlier detection\n  const amounts \u003d [];\n\n  // Map header names to their index\n  const indexes \u003d headers.reduce((acc, header, idx) \u003d\u003e {\n    acc[header] \u003d idx;\n    return acc;\n  }, {});\n\n  // Determine if we perform traditional checks\n  const doTraditionalChecks \u003d [\u0027standard\u0027, \u0027traditional\u0027, \u0027hybrid\u0027].includes(localConfig.detectionAlgorithm.toLowerCase());\n\n  if (doTraditionalChecks) {\n    for (let i \u003d 1; i \u003c data.length; i++) {\n      const row \u003d data[i];\n      const errors \u003d [];\n\n      // Safely retrieve values using the indexes\n      const amountVal \u003d indexes[\u0027amount\u0027] !\u003d\u003d undefined ? row[indexes[\u0027amount\u0027]] : null;\n      const dateVal   \u003d indexes[\u0027date\u0027]   !\u003d\u003d undefined ? row[indexes[\u0027date\u0027]]   : \u0027\u0027;\n      const descVal   \u003d indexes[\u0027description\u0027] !\u003d\u003d undefined ? row[indexes[\u0027description\u0027]] : \u0027\u0027;\n      const catVal    \u003d indexes[\u0027category\u0027]    !\u003d\u003d undefined ? row[indexes[\u0027category\u0027]]    : \u0027\u0027;\n      const emailVal  \u003d indexes[\u0027email\u0027]       !\u003d\u003d undefined ? row[indexes[\u0027email\u0027]]       : null;\n\n      // Convert to string or number forms\n      let amount \u003d parseFloat(amountVal || NaN);\n      let date   \u003d dateVal ? dateVal.toString() : \u0027\u0027;\n      let desc   \u003d descVal.toString();\n      let cat    \u003d catVal.toString();\n      let email  \u003d emailVal ? emailVal.toString() : \u0027\u0027;\n\n      // Check mandatory fields if they\u0027re present\n      localConfig.mandatoryFields.forEach(field \u003d\u003e {\n        const fieldIndex \u003d indexes[field.toLowerCase()];\n        if (fieldIndex !\u003d\u003d undefined) {\n          const fieldValue \u003d row[fieldIndex];\n          if (!fieldValue || fieldValue.toString().trim() \u003d\u003d\u003d \u0027\u0027) {\n            errors.push(`${field} is missing`);\n          }\n        }\n      });\n\n      // 1) Validate Amount\n      if (inferredColumns[\u0027amount\u0027] \u003d\u003d\u003d \u0027numeric\u0027 || !localConfig.dynamicCheck) {\n        if (isNaN(amount)) {\n          errors.push(\u0027Amount is not a number\u0027);\n        } else {\n          if (!localConfig.amount.allowNegative \u0026\u0026 amount \u003c 0) {\n            errors.push(\u0027Negative amount is not allowed\u0027);\n          }\n          if (amount \u003c localConfig.amount.min || amount \u003e localConfig.amount.max) {\n            errors.push(`Amount out of range (${localConfig.amount.min}-${localConfig.amount.max})`);\n          }\n          amounts.push(amount);\n        }\n      }\n\n      // 2) Validate Date\n      if (inferredColumns[\u0027date\u0027] \u003d\u003d\u003d \u0027date\u0027 || !localConfig.dynamicCheck) {\n        if (!isValidDate(date, localConfig)) {\n          errors.push(\u0027Invalid date format\u0027);\n        } else {\n          const parsedDate \u003d parseFlexibleDate(date, localConfig);\n          if (!parsedDate || isNaN(parsedDate.getTime())) {\n            errors.push(\u0027Invalid date content\u0027);\n          } else if (!localConfig.date.allowFuture \u0026\u0026 parsedDate \u003e new Date()) {\n            errors.push(\u0027Future dates are not allowed\u0027);\n          }\n          // Standardize date to ISO string if successfully parsed\n          date \u003d parsedDate ? parsedDate.toISOString().split(\u0027T\u0027)[0] : date;\n        }\n      }\n\n      // 3) Validate Description\n      if (localConfig.description.required \u0026\u0026 desc.trim() \u003d\u003d\u003d \u0027\u0027) {\n        errors.push(\u0027Description is empty\u0027);\n      }\n\n      // 4) Validate Category\n      if (localConfig.category.required \u0026\u0026 cat \u0026\u0026\n          !localConfig.category.validCategories.includes(cat)) {\n        errors.push(`Invalid category: ${cat}`);\n      }\n\n      // 5) Validate Email\n      if (localConfig.email.required) {\n        if (!email || !localConfig.email.format.test(email)) {\n          errors.push(\u0027Invalid email format\u0027);\n        }\n      }\n\n      // 6) Check for duplicates\n      if (localConfig.duplicates.check) {\n        const uniqueKey \u003d localConfig.duplicates.uniqueColumns.map(col \u003d\u003e {\n          const idx \u003d indexes[col.toLowerCase()];\n          return idx !\u003d\u003d undefined ? row[idx] : \u0027\u0027;\n        }).join(\u0027|\u0027);\n        if (seenEntries.has(uniqueKey)) {\n          errors.push(\u0027Duplicate entry detected\u0027);\n        } else {\n          seenEntries.add(uniqueKey);\n        }\n      }\n\n      if (errors.length \u003e 0) {\n        anomalies.push({\n          row: i + 1,  // 1-based index for sheet rows\n          errors,\n          amount,\n          date,\n          description: desc,\n          category: cat,\n          email\n        });\n      }\n    }\n\n    // Outlier detection (if outliers.check \u003d true)\n    if (localConfig.outliers.check \u0026\u0026 localConfig.outliers.method.toLowerCase() !\u003d\u003d \u0027none\u0027 \u0026\u0026 amounts.length \u003e 0) {\n      const outlierAnomalies \u003d detectOutliers(amounts, data, indexes, localConfig);\n      anomalies.push(...outlierAnomalies);\n    }\n\n    logMessage(`Detected ${anomalies.length} anomalies via traditional checks.`);\n  } else {\n    logMessage(`Skipping traditional checks for detectionAlgorithm \u003d \"${localConfig.detectionAlgorithm}\".`);\n  }\n\n  // Optionally integrate AI anomaly detection (if enabled \u0026 relevant)\n  const doAIChecks \u003d localConfig.enableAIDetection \u0026\u0026\n    ([\u0027ai\u0027, \u0027hybrid\u0027, \u0027standard\u0027].includes(localConfig.detectionAlgorithm.toLowerCase()));\n\n  if (doAIChecks) {\n    // This is assumed to be implemented in your environment.\n    const gptResponse \u003d sendQueryToGPT(\u0027Analyze the sheet for anomalies\u0027, data, true);\n    const aiAnomalies \u003d processGPTResponse(gptResponse, true);\n    const validatedAiAnomalies \u003d Array.isArray(aiAnomalies) ? aiAnomalies : [];\n\n    logMessage(`AI Anomalies: ${JSON.stringify(validatedAiAnomalies)}`);\n    return anomalies.concat(validatedAiAnomalies);\n  } else {\n    logMessage(\u0027AI anomaly detection not run. Either disabled or detectionAlgorithm set to skip it.\u0027);\n    return anomalies;\n  }\n}\n\n/**\n * Detect outliers in the amounts array using the method specified in localConfig.outliers.method.\n *\n * Supported methods:\n *   - \u0027zscore\u0027 : Uses the mean and standard deviation with localConfig.outliers.threshold\n *   - \u0027iqr\u0027    : Uses the interquartile range with localConfig.outliers.iqrFactor\n *\n * @param {number[]} amounts - An array of numeric amount values.\n * @param {Array[]} data - The full sheet data (including headers) for referencing date, desc, etc.\n * @param {Object} indexes - A mapping from header strings to column indexes.\n * @param {Object} localConfig - The merged config object containing outlier settings.\n * @returns {Array} - An array of anomaly objects from outlier detection.\n */\nfunction detectOutliers(amounts, data, indexes, localConfig) {\n  const method \u003d localConfig.outliers.method.toLowerCase();\n  const anomalies \u003d [];\n\n  switch (method) {\n    case \u0027zscore\u0027:\n      {\n        const threshold \u003d localConfig.outliers.threshold;\n        const mean \u003d amounts.reduce((a, b) \u003d\u003e a + b, 0) / amounts.length;\n        const stddev \u003d Math.sqrt(\n          amounts.map(x \u003d\u003e Math.pow(x - mean, 2)).reduce((a, b) \u003d\u003e a + b) / amounts.length\n        );\n        // For each amount, check if it\u0027s outside threshold * stddev from mean\n        amounts.forEach((amt, idx) \u003d\u003e {\n          if (stddev \u003e 0 \u0026\u0026 Math.abs(amt - mean) \u003e threshold * stddev) {\n            anomalies.push({\n              row: idx + 1, // 1-based row index offset by header\n              errors: [\u0027Amount is an outlier (Z-score method)\u0027],\n              amount: amt,\n              date: data[idx + 1][indexes[\u0027date\u0027]],\n              description: data[idx + 1][indexes[\u0027description\u0027]],\n              category: data[idx + 1][indexes[\u0027category\u0027]],\n              email: indexes[\u0027email\u0027] !\u003d\u003d undefined ? data[idx + 1][indexes[\u0027email\u0027]] : null\n            });\n          }\n        });\n      }\n      break;\n\n    case \u0027iqr\u0027:\n      {\n        // Sort the amounts for percentile-based calculations\n        const sorted \u003d [...amounts].sort((a, b) \u003d\u003e a - b);\n        const q1 \u003d percentile(sorted, 25);\n        const q3 \u003d percentile(sorted, 75);\n        const iqr \u003d q3 - q1;\n        const factor \u003d localConfig.outliers.iqrFactor;\n\n        const lowerBound \u003d q1 - factor * iqr;\n        const upperBound \u003d q3 + factor * iqr;\n\n        amounts.forEach((amt, idx) \u003d\u003e {\n          if (amt \u003c lowerBound || amt \u003e upperBound) {\n            anomalies.push({\n              row: idx + 1,\n              errors: [\u0027Amount is an outlier (IQR method)\u0027],\n              amount: amt,\n              date: data[idx + 1][indexes[\u0027date\u0027]],\n              description: data[idx + 1][indexes[\u0027description\u0027]],\n              category: data[idx + 1][indexes[\u0027category\u0027]],\n              email: indexes[\u0027email\u0027] !\u003d\u003d undefined ? data[idx + 1][indexes[\u0027email\u0027]] : null\n            });\n          }\n        });\n      }\n      break;\n\n    // Add more methods here if needed (e.g., \u0027mad\u0027, \u0027robustZscore\u0027), but avoid stubs.\n\n    default:\n      // If unknown method or \u0027none\u0027, do nothing\n      logMessage(`Outlier detection method \"${method}\" not recognized or set to none. Skipping outlier detection.`);\n      break;\n  }\n\n  return anomalies;\n}\n\n/**\n * Percentile helper function (e.g., 25th, 75th).\n * @param {number[]} arr - Sorted array of numbers.\n * @param {number} percentile - A value between 0 and 100.\n * @returns {number} - The percentile value.\n */\nfunction percentile(arr, percentile) {\n  const index \u003d (percentile / 100) * (arr.length - 1);\n  if (Math.floor(index) \u003d\u003d\u003d index) {\n    return arr[index];\n  } else {\n    const i \u003d Math.floor(index);\n    const fraction \u003d index - i;\n    return arr[i] + (arr[i + 1] - arr[i]) * fraction;\n  }\n}\n\n/**\n * Function to highlight anomalies in the spreadsheet.\n * @param {Sheet} sheet - The sheet to highlight anomalies in.\n * @param {Array} anomalies - The list of anomalies to highlight.\n */\nfunction highlightAnomalies(sheet, anomalies) {\n  if (!Array.isArray(anomalies)) {\n    logError(\u0027highlightAnomalies expects an array of anomalies.\u0027);\n    return;\n  }\n\n  anomalies.forEach(anomaly \u003d\u003e {\n    const row \u003d anomaly.row;\n    const range \u003d sheet.getRange(row, 1, 1, sheet.getLastColumn());\n\n    logMessage(`Highlighting row ${row} with anomalies: ${JSON.stringify(anomaly.errors)}`);\n\n    range.setBackground(\u0027red\u0027);\n    range.setNote(anomaly.errors.join(\u0027, \u0027));\n  });\n\n  logMessage(`Highlighted ${anomalies.length} anomalies in the spreadsheet.`);\n}\n\n/**\n * Create a new sheet with detailed error/anomaly reports.\n * @param {Array|Object} anomalies - The list of anomalies to report.\n */\nfunction createErrorReportSheet(anomalies) {\n  anomalies \u003d convertToArray(anomalies); // Ensure anomalies is an array\n\n  if (!Array.isArray(anomalies)) {\n    logError(\u0027createErrorReportSheet expects an array of anomalies.\u0027);\n    return;\n  }\n\n  const spreadsheet \u003d SpreadsheetApp.getActiveSpreadsheet();\n  const sheetName \u003d \u0027Error Report\u0027;\n  let errorSheet \u003d spreadsheet.getSheetByName(sheetName);\n\n  if (errorSheet) {\n    spreadsheet.deleteSheet(errorSheet);\n    logMessage(`Deleted existing sheet: ${sheetName}`);\n  }\n\n  errorSheet \u003d spreadsheet.insertSheet(sheetName);\n  logMessage(`Created new sheet: ${sheetName}`);\n\n  const headers \u003d [\u0027Row\u0027, \u0027Amount\u0027, \u0027Date\u0027, \u0027Description\u0027, \u0027Category\u0027, \u0027Email\u0027, \u0027Errors\u0027];\n  const headerRange \u003d errorSheet.getRange(1, 1, 1, headers.length);\n  headerRange.setValues([headers]);\n\n  // Header styling\n  headerRange.setFontWeight(\u0027bold\u0027);\n  headerRange.setBackground(\u0027#4caf50\u0027);\n  headerRange.setFontColor(\u0027white\u0027);\n  headerRange.setHorizontalAlignment(\u0027center\u0027);\n  headerRange.setBorder(true, true, true, true, true, true);\n\n  // Append anomaly rows\n  anomalies.forEach((anomaly, index) \u003d\u003e {\n    const row \u003d [\n      anomaly.row,\n      anomaly.amount,\n      anomaly.date,\n      anomaly.description,\n      anomaly.category,\n      anomaly.email || \u0027\u0027,\n      Array.isArray(anomaly.errors) ? anomaly.errors.join(\u0027, \u0027) : anomaly.errors\n    ];\n    const rowIndex \u003d index + 2;\n    const range \u003d errorSheet.getRange(rowIndex, 1, 1, row.length);\n    range.setValues([row]);\n\n    // Optional row styling\n    range.setBackground(rowIndex % 2 \u003d\u003d\u003d 0 ? \u0027#f1f8e9\u0027 : \u0027#ffffff\u0027);\n    range.setBorder(true, true, true, true, true, true);\n    range.setHorizontalAlignment(\u0027center\u0027);\n  });\n\n  // Summary row\n  const summaryRowIndex \u003d anomalies.length + 2;\n  const summaryRow \u003d [\u0027Total Anomalies\u0027, anomalies.length];\n  while (summaryRow.length \u003c headers.length) {\n    summaryRow.push(\u0027\u0027);\n  }\n  const summaryRange \u003d errorSheet.getRange(summaryRowIndex, 1, 1, headers.length);\n  summaryRange.setValues([summaryRow]);\n  summaryRange.setFontWeight(\u0027bold\u0027);\n  summaryRange.setBackground(\u0027#ffeb3b\u0027);\n  summaryRange.setHorizontalAlignment(\u0027center\u0027);\n  summaryRange.setBorder(true, true, true, true, true, true);\n\n  // Auto-resize columns and freeze the header\n  errorSheet.autoResizeColumns(1, headers.length);\n  errorSheet.setFrozenRows(1);\n\n  logMessage(`Added ${anomalies.length} anomalies to the error report sheet.`);\n}\n\n/**\n * Attempt to infer column types if localConfig.dynamicCheck is true\n * - Looks at the first few rows to see if data is mostly numeric or date-like.\n * @param {string[]} headers - The array of header strings.\n * @param {Array[]} data - All sheet data, including header row.\n * @returns {Object} - A map of header -\u003e \u0027numeric\u0027, \u0027date\u0027, or \u0027string\u0027.\n */\nfunction inferColumnTypes(headers, data) {\n  const sampleSize \u003d Math.min(data.length - 1, 10);\n  const typeCounts \u003d {};\n\n  headers.forEach(header \u003d\u003e {\n    typeCounts[header] \u003d { numeric: 0, date: 0, string: 0 };\n  });\n\n  for (let i \u003d 1; i \u003c\u003d sampleSize; i++) {\n    const row \u003d data[i];\n    headers.forEach((header, idx) \u003d\u003e {\n      const cellValue \u003d row[idx];\n      if (cellValue \u003d\u003d\u003d null || cellValue \u003d\u003d\u003d \u0027\u0027) {\n        // skip empty\n      } else if (!isNaN(parseFloat(cellValue)) \u0026\u0026 isFinite(cellValue)) {\n        typeCounts[header].numeric++;\n      } else if (isLikelyDate(cellValue)) {\n        typeCounts[header].date++;\n      } else {\n        typeCounts[header].string++;\n      }\n    });\n  }\n\n  const inferred \u003d {};\n  Object.keys(typeCounts).forEach(header \u003d\u003e {\n    const { numeric, date, string } \u003d typeCounts[header];\n    const maxCount \u003d Math.max(numeric, date, string);\n    if (maxCount \u003d\u003d\u003d numeric) {\n      inferred[header] \u003d \u0027numeric\u0027;\n    } else if (maxCount \u003d\u003d\u003d date) {\n      inferred[header] \u003d \u0027date\u0027;\n    } else {\n      inferred[header] \u003d \u0027string\u0027;\n    }\n  });\n\n  return inferred;\n}\n\n/**\n * Check if a value is likely a date (string or Date object).\n * @param {any} cellValue - The cell value to test.\n * @returns {boolean}\n */\nfunction isLikelyDate(cellValue) {\n  if (Object.prototype.toString.call(cellValue) \u003d\u003d\u003d \u0027[object Date]\u0027) {\n    return true;\n  }\n  const str \u003d cellValue.toString().trim();\n  return /^[0-9/\\\\-]+$/.test(str);\n}\n\n/**\n * Checks whether a string is a valid date based on localConfig.date.datePatterns\n * or if Date(...) can parse it.\n *\n * @param {string} str - The date string.\n * @param {Object} localConfig - The config object with date patterns.\n * @returns {boolean}\n */\nfunction isValidDate(str, localConfig) {\n  for (const pattern of localConfig.date.datePatterns) {\n    if (pattern.test(str)) {\n      return true;\n    }\n  }\n  const testDate \u003d new Date(str);\n  return !isNaN(testDate.getTime());\n}\n\n/**\n * Parses a string into a Date object if it matches known patterns or can be parsed directly by Date().\n * @param {string} str - The date string.\n * @param {Object} localConfig - The config object (with datePatterns).\n * @returns {Date|null} - The parsed Date object, or null if parsing fails.\n */\nfunction parseFlexibleDate(str, localConfig) {\n  let d \u003d new Date(str);\n  if (!isNaN(d.getTime())) {\n    return d;\n  }\n  for (const pattern of localConfig.date.datePatterns) {\n    if (pattern.test(str)) {\n      if (/^\\d{2}\\/\\d{2}\\/\\d{4}$/.test(str)) {\n        const [mm, dd, yyyy] \u003d str.split(\u0027/\u0027);\n        return new Date(+yyyy, +mm - 1, +dd);\n      }\n      if (/^\\d{4}-\\d{2}-\\d{2}$/.test(str)) {\n        const [yyyy, mm, dd] \u003d str.split(\u0027-\u0027);\n        return new Date(+yyyy, +mm - 1, +dd);\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Convert input (array, object, or JSON string) to an array of anomalies.\n * @param {any} input - The input to convert.\n * @returns {Array} - An array of anomalies.\n */\nfunction convertToArray(input) {\n  if (Array.isArray(input)) {\n    return input;\n  } else if (typeof input \u003d\u003d\u003d \u0027object\u0027 \u0026\u0026 input !\u003d\u003d null) {\n    if (input.anomalies \u0026\u0026 Array.isArray(input.anomalies)) {\n      return input.anomalies;\n    } else {\n      return Object.values(input);\n    }\n  } else {\n    try {\n      return JSON.parse(input);\n    } catch (error) {\n      logError(\u0027Failed to convert input to array: \u0027 + error.message);\n      return [];\n    }\n  }\n}\n\n/**\n * Utility function to log messages for debugging.\n * @param {string} message - The message to log.\n */\nfunction logMessage(message) {\n  Logger.log(`[INFO] [${new Date().toISOString()}] ${message}`);\n}\n\n/**\n * Utility function to log error messages.\n * @param {string} errorMessage - The error message to log.\n */\nfunction logError(errorMessage) {\n  Logger.log(`[ERROR] [${new Date().toISOString()}] ${errorMessage}`);\n}\n"},{"id":"b4ff88ba-fb2d-41db-ac6c-4920124c2295","name":"customGPT","type":"server_js","source":"// Your OpenAI GPT API endpoint\nconst OPENAI_GPT_API_ENDPOINT \u003d \u0027https://api.openai.com/v1/chat/completions\u0027;\n\n/**\n * Retrieve the OpenAI API key from Script Properties\n * @returns {string} - The API key.\n */\nfunction getOpenAIApiKey() {\n  return PropertiesService.getScriptProperties().getProperty(\u0027OPENAI_API_KEY\u0027) || \u0027\u0027;\n}\n\n/**\n * Retrieve the GPT model from Script Properties (fallback: gpt-4o)\n * @returns {string} - The GPT model name.\n */\nfunction getGptModel() {\n  return PropertiesService.getScriptProperties().getProperty(\u0027OPENAI_MODEL\u0027) || \u0027gpt-4o\u0027;\n}\n\n/**\n * Function to send a query to the OpenAI GPT model\n * @param {string} query - The query to send to the GPT model.\n * @param {Array} sheetData - The data from the Google Sheet to include in the context.\n * @param {boolean} [isFullProcess\u003dfalse] - Flag to indicate if it\u0027s a full-process sheet request.\n * @param {Object} [advancedParams] - Optional advanced GPT parameters (e.g., temperature, top_p).\n * @returns {Object} - The response from the GPT model or an error message.\n */\nfunction sendQueryToGPT(query, sheetData, isFullProcess, advancedParams) {\n  const apiKey \u003d getOpenAIApiKey();\n  if (!apiKey) {\n    logError(\u0027OpenAI API key is not set in script properties.\u0027);\n    return { error: \u0027OpenAI API key is not configured.\u0027 };\n  }\n\n  // By default, the system message is either a \"full process\" or \"normal\" prompt\n  const systemMessage \u003d isFullProcess\n    ? \u0027You are an intelligent assistant specialized in accounting and financial analysis. You are tasked with identifying anomalies in transaction data, such as unusual amounts, dates, or descriptions. Analyze the provided spreadsheet data and respond in a structured JSON format without additional content. Format example: {\"anomalies\":[{\"row\":1,\"amount\":5000,\"date\":\"2024-01-01\",\"description\":\"Software Purchase\",\"category\":\"Sales\",\"email\":\"\",\"errors\":[\"Large Amount\"]},...]}\u0027\n    : \u0027You are an intelligent assistant specialized in accounting and financial analysis. Use the provided data to respond accurately to the user\\\u0027s query.\u0027;\n\n  // Potential chunking if sheetData is extremely large\n  // Convert each row to a string, join them, then chunk if needed\n  const serializedData \u003d chunkSheetDataIfNeeded(sheetData);\n\n  const messages \u003d [\n    { role: \u0027system\u0027, content: systemMessage },\n    { role: \u0027user\u0027, content: `Spreadsheet Data (chunked if large): ${serializedData}` },\n    { role: \u0027user\u0027, content: query }\n  ];\n\n  // Merge advanced parameters if provided (e.g., temperature, top_p, etc.)\n  // without breaking existing usage\n  const payload \u003d Object.assign(\n    {\n      model: getGptModel(),\n      messages: messages,\n      max_tokens: 500\n    },\n    advancedParams || {}\n  );\n\n  const options \u003d {\n    method: \u0027post\u0027,\n    contentType: \u0027application/json\u0027,\n    payload: JSON.stringify(payload),\n    headers: {\n      \u0027Authorization\u0027: `Bearer ${apiKey}`\n    },\n    muteHttpExceptions: true\n  };\n\n  try {\n    logMessage(`Sending request to GPT with payload: ${JSON.stringify(payload)}`);\n    const response \u003d fetchWithRetry(OPENAI_GPT_API_ENDPOINT, options);\n    logMessage(`Received response from GPT: ${JSON.stringify(response)}`);\n    return response; // Return the full JSON response for better handling\n  } catch (e) {\n    logError(`Error in sendQueryToGPT: ${e.message}`);\n    return { error: \u0027There was an error connecting to the GPT service.\u0027 };\n  }\n}\n\n/**\n * Chunk large sheet data if needed. If the joined data is bigger than a certain limit,\n * we break it into multiple lines with an indicator. For example, ~10K characters limit to reduce token usage.\n * @param {Array} sheetData - The data from the Google Sheet\n * @returns {string} - A chunked/serialized string representation of the data\n */\nfunction chunkSheetDataIfNeeded(sheetData) {\n  if (!Array.isArray(sheetData)) {\n    return \u0027No data available.\u0027;\n  }\n  // Convert data into lines\n  const lines \u003d sheetData.map(row \u003d\u003e row.join(\u0027,\u0027)).join(\u0027\\\\n\u0027);\n\n  // If lines is too large, chunk it\n  const MAX_LENGTH \u003d 10000; // you can tweak this to fit your usage constraints\n  if (lines.length \u003c\u003d MAX_LENGTH) {\n    return lines;\n  } else {\n    logMessage(`Sheet data is too large (${lines.length} chars). Chunking to first ${MAX_LENGTH} characters.`);\n    return lines.substring(0, MAX_LENGTH) + \u0027... [TRUNCATED DATA]\u0027;\n  }\n}\n\n/**\n * Function to fetch with retry mechanism and exponential backoff\n * @param {string} url - The URL to fetch.\n * @param {object} options - The fetch options.\n * @param {number} [retries\u003d3] - The number of retries.\n * @param {number} [backoff\u003d1000] - The backoff time in milliseconds.\n * @returns {Object} - The response from the API or throws an error if all attempts fail.\n */\nfunction fetchWithRetry(url, options, retries \u003d 3, backoff \u003d 1000) {\n  while (retries \u003e 0) {\n    try {\n      const response \u003d UrlFetchApp.fetch(url, options);\n      const responseCode \u003d response.getResponseCode();\n      logMessage(`Response code from GPT: ${responseCode}`);\n\n      if (responseCode \u003d\u003d\u003d 200) {\n        const jsonResponse \u003d JSON.parse(response.getContentText());\n        logMessage(`Successful fetch: ${JSON.stringify(jsonResponse)}`);\n        return jsonResponse; // Return the entire JSON response\n      } else {\n        // Enhanced error checks for specific codes\n        let errorMsg \u003d `Error in GPT response: ${response.getContentText()}`;\n        switch (responseCode) {\n          case 401:\n            logError(`Unauthorized (401). Check API key. Body: ${errorMsg}`);\n            break;\n          case 429:\n            logError(\u0027Rate limited by GPT API. Waiting 5 seconds before retrying...\u0027);\n            Utilities.sleep(5000);\n            retries--;\n            backoff *\u003d 2;\n            continue; // retry\n          default:\n            logError(`HTTP Status ${responseCode}. ${errorMsg}`);\n            break;\n        }\n        // If not a special case or after handling it, do a standard backoff\n        retries--;\n        Utilities.sleep(backoff);\n        backoff *\u003d 2;\n      }\n    } catch (e) {\n      logError(`Fetch attempt failed: ${e.message}`);\n      retries--;\n      Utilities.sleep(backoff);\n      backoff *\u003d 2;\n    }\n  }\n  throw new Error(\u0027Failed to fetch from GPT API after multiple attempts.\u0027);\n}\n\n/**\n * Utility function to extract JSON from GPT response string\n * @param {string} responseStr - The response string from GPT.\n * @returns {string} - Extracted JSON string.\n */\nfunction extractJson(responseStr) {\n  responseStr \u003d responseStr.replace(/```json|```/g, \u0027\u0027).trim();\n\n  // Extract JSON content between the first \u0027{\u0027 and the last \u0027}\u0027\n  const startJsonIndex \u003d responseStr.indexOf(\u0027{\u0027);\n  const endJsonIndex \u003d responseStr.lastIndexOf(\u0027}\u0027) + 1;\n\n  if (startJsonIndex \u003d\u003d\u003d -1 || endJsonIndex \u003d\u003d\u003d 0) {\n    throw new Error(\u0027JSON portion not found in the response.\u0027);\n  }\n\n  return responseStr.substring(startJsonIndex, endJsonIndex);\n}\n\n/**\n * Utility function to validate anomalies array\n * @param {Object} parsedResponse - Parsed JSON response.\n * @returns {Array} - Validated anomalies array.\n */\nfunction validateAnomalies(parsedResponse) {\n  if (parsedResponse \u0026\u0026 parsedResponse.anomalies \u0026\u0026 Array.isArray(parsedResponse.anomalies)) {\n    return parsedResponse.anomalies;\n  } else {\n    logMessage(\u0027Invalid anomalies array structure: \u0027 + JSON.stringify(parsedResponse));\n    throw new Error(\u0027Parsed response does not contain a valid anomalies array.\u0027);\n  }\n}\n\n/**\n * Function to process the GPT model response\n * @param {string|Object} response - The response from the GPT model.\n * @param {boolean} [isFullProcess\u003dfalse] - Flag to indicate if it\u0027s a full process sheet request.\n * @returns {Array|String} - The processed anomalies array or a string message.\n */\nfunction processGPTResponse(response, isFullProcess) {\n  try {\n    logMessage(`Raw GPT Response: ${JSON.stringify(response)}`);\n\n    // Ensure response is a string or convert to string\n    const responseStr \u003d typeof response \u003d\u003d\u003d \u0027string\u0027 ? response : JSON.stringify(response);\n\n    // Attempt to extract JSON portion\n    const startJsonIndex \u003d responseStr.indexOf(\u0027{\u0027);\n    const endJsonIndex \u003d responseStr.lastIndexOf(\u0027}\u0027) + 1;\n\n    if (startJsonIndex \u003d\u003d\u003d -1 || endJsonIndex \u003d\u003d\u003d 0) {\n      throw new Error(\u0027JSON portion not found in the response.\u0027);\n    }\n\n    const jsonResponse \u003d responseStr.substring(startJsonIndex, endJsonIndex);\n    logMessage(`Extracted JSON Response: ${jsonResponse}`);\n\n    const parsedResponse \u003d JSON.parse(jsonResponse);\n\n    // Optionally log usage if available\n    if (parsedResponse.usage \u0026\u0026 parsedResponse.usage.total_tokens) {\n      logMessage(`GPT usage tokens: ${parsedResponse.usage.total_tokens}`);\n    }\n\n    if (isFullProcess) {\n      // If anomalies array is in top-level JSON\n      if (parsedResponse \u0026\u0026 parsedResponse.anomalies \u0026\u0026 Array.isArray(parsedResponse.anomalies)) {\n        logMessage(\u0027Returning anomalies from top-level JSON.\u0027);\n        return parsedResponse.anomalies;\n      }\n      // Handle nested JSON content case\n      else if (\n        parsedResponse \u0026\u0026\n        parsedResponse.choices \u0026\u0026\n        parsedResponse.choices[0] \u0026\u0026\n        parsedResponse.choices[0].message \u0026\u0026\n        parsedResponse.choices[0].message.content\n      ) {\n        const content \u003d parsedResponse.choices[0].message.content;\n        const startContentJsonIndex \u003d content.indexOf(\u0027{\u0027);\n        const endContentJsonIndex \u003d content.lastIndexOf(\u0027}\u0027) + 1;\n\n        if (startContentJsonIndex \u003d\u003d\u003d -1 || endContentJsonIndex \u003d\u003d\u003d 0) {\n          throw new Error(\u0027JSON portion not found in the response content.\u0027);\n        }\n\n        const contentJsonResponse \u003d content.substring(startContentJsonIndex, endContentJsonIndex);\n        logMessage(`Extracted Content JSON Response: ${contentJsonResponse}`);\n\n        const parsedContentResponse \u003d JSON.parse(contentJsonResponse);\n        if (parsedContentResponse \u0026\u0026 parsedContentResponse.anomalies \u0026\u0026 Array.isArray(parsedContentResponse.anomalies)) {\n          logMessage(\u0027Returning anomalies from nested JSON content.\u0027);\n          return parsedContentResponse.anomalies;\n        } else {\n          throw new Error(\u0027Parsed content response does not contain an anomalies array.\u0027);\n        }\n      } else {\n        throw new Error(\u0027Parsed response does not contain an anomalies array.\u0027);\n      }\n    } else {\n      // For chat response, we handle as string content\n      if (\n        parsedResponse \u0026\u0026\n        parsedResponse.choices \u0026\u0026\n        parsedResponse.choices[0] \u0026\u0026\n        parsedResponse.choices[0].message \u0026\u0026\n        parsedResponse.choices[0].message.content\n      ) {\n        return parsedResponse.choices[0].message.content;\n      } else {\n        throw new Error(\u0027Invalid response format for chat.\u0027);\n      }\n    }\n  } catch (error) {\n    logError(\u0027Error parsing GPT JSON response: \u0027 + error.message);\n    return \u0027Error parsing GPT response.\u0027;\n  }\n}\n\n/**\n * Function to handle user queries and return GPT responses\n * @param {string} query - The user\u0027s query.\n * @returns {string} - The response from the GPT model.\n */\nfunction handleUserQuery(query) {\n  if (!query || query.trim() \u003d\u003d\u003d \u0027\u0027) {\n    return \u0027Query cannot be empty.\u0027;\n  }\n\n  logMessage(`Handling user query: ${query}`);\n  const sheetData \u003d getSheetData();\n  const gptResponse \u003d sendQueryToGPT(query, sheetData);\n  const processedResponse \u003d processGPTResponse(gptResponse);\n  logMessage(`GPT response processed: ${processedResponse}`);\n  return processedResponse;\n}\n\n/**\n * Utility function to get data from the active Google Sheet\n * @returns {Array} - The data from the sheet.\n */\nfunction getSheetData() {\n  try {\n    const sheet \u003d SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();\n    if (!sheet) throw new Error(\u0027No active sheet found.\u0027);\n    const range \u003d sheet.getDataRange();\n    const data \u003d range.getValues();\n    logMessage(`Retrieved data from sheet: ${JSON.stringify(data)}`);\n    return data;\n  } catch (error) {\n    logError(`Error getting sheet data: ${error.message}`);\n    return [];\n  }\n}\n\n/**\n * Function to highlight anomalies in the spreadsheet\n * @param {Sheet} sheet - The sheet to highlight anomalies in.\n * @param {Array|Object} anomalies - The list of anomalies to highlight.\n */\nfunction highlightAnomalies(sheet, anomalies) {\n  anomalies \u003d convertToArray(anomalies); // Ensure anomalies is an array\n\n  if (!Array.isArray(anomalies)) {\n    logError(\u0027highlightAnomalies expects an array of anomalies.\u0027);\n    return;\n  }\n\n  anomalies.forEach(anomaly \u003d\u003e {\n    const row \u003d anomaly.row;\n    const range \u003d sheet.getRange(row, 1, 1, sheet.getLastColumn());\n    range.setBackground(\u0027red\u0027);\n    range.setNote(anomaly.errors.join(\u0027, \u0027)); // Adding notes for anomalies\n  });\n  logMessage(`Highlighted ${anomalies.length} anomalies in the spreadsheet.`);\n}\n\n/**\n * Utility function to log messages for debugging\n * @param {string} message - The message to log.\n */\nfunction logMessage(message) {\n  Logger.log(`[INFO] [${new Date().toISOString()}] ${message}`);\n}\n\n/**\n * Utility function to log error messages\n * @param {string} errorMessage - The error message to log.\n */\nfunction logError(errorMessage) {\n  Logger.log(`[ERROR] [${new Date().toISOString()}] ${errorMessage}`);\n}\n\n/**\n * Converts various input to an array if necessary\n * @param {any} input - The input to convert\n * @returns {Array} - The converted array\n */\nfunction convertToArray(input) {\n  if (Array.isArray(input)) {\n    return input;\n  } else if (typeof input \u003d\u003d\u003d \u0027object\u0027 \u0026\u0026 input !\u003d\u003d null) {\n    if (input.anomalies \u0026\u0026 Array.isArray(input.anomalies)) {\n      return input.anomalies;\n    } else {\n      return Object.values(input);\n    }\n  } else {\n    try {\n      return JSON.parse(input);\n    } catch (error) {\n      logError(\u0027Failed to convert input to array: \u0027 + error.message);\n      return [];\n    }\n  }\n}\n"},{"id":"0cb1b045-107d-408d-ade6-fa3a034e61e5","name":"main","type":"server_js","source":"/**\n * Function to add custom menu on spreadsheet open\n */\nfunction onOpen() {\n  if (isRunningInSpreadsheetContext()) {\n    try {\n      const ui \u003d SpreadsheetApp.getUi();\n      ui.createMenu(\u0027Fiscal Eye\u0027)\n        .addItem(\u0027Initialize GPT\u0027, \u0027initializeCustomGPT\u0027)\n        .addItem(\u0027Analyze Spreadsheet\u0027, \u0027handleSpreadsheetAnomalies\u0027)\n        .addItem(\u0027Open Chat\u0027, \u0027createSideWindowChat\u0027)\n        .addItem(\u0027QuickBooks Integration\u0027, \u0027showQuickbooksConfigDialog\u0027)\n        .addItem(\u0027Generate Report\u0027, \u0027showReportMenu\u0027)\n        .addItem(\u0027Process Entire Spreadsheet\u0027, \u0027processEntireSpreadsheet\u0027)\n        .addToUi();\n      logMessage(\u0027Custom menu added successfully.\u0027);\n    } catch (error) {\n      logError(\u0027Error adding custom menu: \u0027 + error.message);\n      if (isRunningInSpreadsheetContext()) {\n        SpreadsheetApp.getUi().alert(\u0027An error occurred while adding the custom menu. Check logs for details.\u0027);\n      }\n    }\n  } else {\n    logMessage(\u0027Not running in spreadsheet context. No action taken.\u0027);\n  }\n}\n\n/**\n * Function to show QuickBooks configuration dialog\n */\nfunction showQuickbooksConfigDialog() {\n  try {\n    const htmlOutput \u003d HtmlService.createHtmlOutputFromFile(\u0027quickbooksConfig\u0027)\n      .setWidth(500)\n      .setHeight(600);\n    SpreadsheetApp.getUi().showModalDialog(htmlOutput, \u0027QuickBooks Integration\u0027);\n    logMessage(\u0027QuickBooks configuration dialog displayed successfully.\u0027);\n  } catch (error) {\n    logError(\u0027Error showing QuickBooks configuration dialog: \u0027 + error.message);\n    if (isRunningInSpreadsheetContext()) {\n      SpreadsheetApp.getUi().alert(\u0027Failed to display QuickBooks configuration dialog. Please check the logs for more details.\u0027);\n    }\n  }\n}\n\n/**\n * Initialize the custom GPT model\n */\nfunction initializeCustomGPT() {\n  try {\n    logMessage(\u0027Initializing custom GPT model...\u0027);\n    // Here you can add any extra setup for GPT if needed (key checks, environment verification, etc.)\n    logMessage(\u0027Fiscal Eye model initialized successfully.\u0027);\n    if (isRunningInSpreadsheetContext()) {\n      SpreadsheetApp.getUi().alert(\u0027Custom GPT model initialized successfully.\u0027);\n    }\n  } catch (error) {\n    logError(\u0027Error initializing custom GPT model: \u0027 + error.message);\n    if (isRunningInSpreadsheetContext()) {\n      SpreadsheetApp.getUi().alert(\u0027Failed to initialize custom GPT model. Please check the logs for more details.\u0027);\n    }\n  }\n}\n\n/**\n * Handle spreadsheet anomalies\n */\nfunction handleSpreadsheetAnomalies() {\n  try {\n    const sheet \u003d getActiveSheet();\n    logMessage(\u0027Analyzing spreadsheet for anomalies...\u0027);\n\n    const anomalies \u003d convertToArray(detectAnomalies(sheet));\n\n    if (Array.isArray(anomalies)) {\n      logMessage(`Detected ${anomalies.length} anomalies.`);\n      highlightAnomalies(sheet, anomalies);\n      createErrorReportSheet(anomalies);\n      logMessage(\u0027Spreadsheet anomalies handled successfully.\u0027);\n      if (isRunningInSpreadsheetContext()) {\n        SpreadsheetApp.getUi().alert(\u0027Spreadsheet analysis complete. Anomalies highlighted and error report created.\u0027);\n      }\n    } else {\n      logError(\u0027Anomalies is not an array.\u0027);\n    }\n  } catch (error) {\n    logError(\u0027Error handling spreadsheet anomalies: \u0027 + error.message);\n    if (isRunningInSpreadsheetContext()) {\n      SpreadsheetApp.getUi().alert(\u0027Failed to analyze spreadsheet. Please check the logs for more details.\u0027);\n    }\n  }\n}\n\n/**\n * Create the side-window chat interface\n */\nfunction createSideWindowChat() {\n  try {\n    const htmlOutput \u003d HtmlService.createHtmlOutputFromFile(\u0027sideWindowChatScreen\u0027)\n      .setWidth(400)\n      .setHeight(600);\n    SpreadsheetApp.getUi().showSidebar(htmlOutput);\n    logMessage(\u0027Side-window chat interface created successfully.\u0027);\n  } catch (error) {\n    logError(\u0027Error creating side-window chat interface: \u0027 + error.message);\n    if (isRunningInSpreadsheetContext()) {\n      SpreadsheetApp.getUi().alert(\u0027Failed to create side-window chat interface. Please check the logs for more details.\u0027);\n    }\n  }\n}\n\n/**\n * Trigger to run when the spreadsheet is opened\n */\nfunction onOpenTrigger() {\n  onOpen();\n}\n\n/**\n * Set up the script triggers\n */\nfunction setupTriggers() {\n  try {\n    const spreadsheet \u003d getOrCreateSpreadsheet();\n    const triggers \u003d ScriptApp.getProjectTriggers().filter(tr \u003d\u003e tr.getHandlerFunction() \u003d\u003d\u003d \u0027onOpenTrigger\u0027);\n    if (triggers.length \u003d\u003d\u003d 0) {\n      ScriptApp.newTrigger(\u0027onOpenTrigger\u0027)\n        .forSpreadsheet(spreadsheet)\n        .onOpen()\n        .create();\n      logMessage(\u0027Script triggers set up successfully.\u0027);\n    } else {\n      logMessage(\u0027onOpenTrigger already exists. No new trigger created.\u0027);\n    }\n  } catch (error) {\n    logError(\u0027Error setting up script triggers: \u0027 + error.message);\n    if (isRunningInSpreadsheetContext()) {\n      SpreadsheetApp.getUi().alert(\u0027Failed to set up script triggers. Please check the logs for more details.\u0027);\n    }\n  }\n}\n\n/**\n * Initialize the script\n */\nfunction initialize() {\n  try {\n    const spreadsheet \u003d getOrCreateSpreadsheet();\n    if (!spreadsheet) {\n      throw new Error(\u0027Failed to create or retrieve the spreadsheet.\u0027);\n    }\n    setupTriggers();\n    logMessage(\u0027Script initialized successfully.\u0027);\n    if (isRunningInSpreadsheetContext()) {\n      SpreadsheetApp.getUi().alert(\u0027Script initialized successfully.\u0027);\n    }\n  } catch (error) {\n    logError(\u0027Error initializing script: \u0027 + error.message);\n    if (isRunningInSpreadsheetContext()) {\n      SpreadsheetApp.getUi().alert(\u0027Failed to initialize script. Please check the logs for more details.\u0027);\n    }\n  }\n}\n\n/**\n * Get the active sheet in Google Drive\n * @returns {Sheet} - The active sheet.\n */\nfunction getActiveSheet() {\n  try {\n    const spreadsheet \u003d SpreadsheetApp.getActiveSpreadsheet();\n    if (!spreadsheet) {\n      throw new Error(\u0027No active spreadsheet found.\u0027);\n    }\n    const sheet \u003d spreadsheet.getActiveSheet();\n    if (!sheet) {\n      throw new Error(\u0027No active sheet found.\u0027);\n    }\n    logMessage(`Using active sheet: ${sheet.getName()}`);\n    return sheet;\n  } catch (error) {\n    logError(`Error retrieving active sheet: ${error.message}`);\n    throw new Error(\u0027Failed to retrieve the active sheet.\u0027);\n  }\n}\n\n/**\n * Get or create a new spreadsheet in Google Drive\n * @returns {Spreadsheet} - The active spreadsheet.\n */\nfunction getOrCreateSpreadsheet() {\n  try {\n    let spreadsheet \u003d SpreadsheetApp.getActiveSpreadsheet();\n    if (!spreadsheet) {\n      const fileName \u003d \u0027FiscalEye_Spreadsheet_\u0027 + new Date().getTime();\n      spreadsheet \u003d SpreadsheetApp.create(fileName);\n      logMessage(`Created a new spreadsheet in Google Drive with name: ${fileName}`);\n    } else {\n      logMessage(`Using existing active spreadsheet with ID: ${spreadsheet.getId()}`);\n    }\n    return spreadsheet;\n  } catch (error) {\n    logError(`Error creating or retrieving spreadsheet: ${error.message}`);\n    throw new Error(\u0027Failed to create or retrieve the spreadsheet.\u0027);\n  }\n}\n\n/**\n * Process the entire spreadsheet to detect anomalies and highlight them using AI.\n */\nfunction processEntireSpreadsheet() {\n  try {\n    const spreadsheet \u003d SpreadsheetApp.getActiveSpreadsheet();\n    const sheets \u003d spreadsheet.getSheets();\n    let allAnomalies \u003d [];\n\n    sheets.forEach(sheet \u003d\u003e {\n      const sheetData \u003d sheet.getDataRange().getValues();\n      logMessage(`Processing sheet: ${sheet.getName()}`);\n      const gptResponse \u003d sendQueryToGPT(\u0027Analyze the sheet for anomalies\u0027, sheetData, true);\n      logMessage(`GPT response for sheet ${sheet.getName()}: ${JSON.stringify(gptResponse)}`);\n\n      let anomalies \u003d processGPTResponse(gptResponse, true);\n\n      logMessage(`Anomalies detected in sheet ${sheet.getName()}: ${JSON.stringify(anomalies)}`);\n      logMessage(`Type of anomalies: ${typeof anomalies}`);\n\n      anomalies \u003d convertToArray(anomalies);\n\n      logMessage(`Type of anomalies after conversion: ${typeof anomalies}`);\n\n      if (Array.isArray(anomalies)) {\n        logMessage(`Highlighting anomalies in sheet ${sheet.getName()}`);\n        highlightAnomalies(sheet, anomalies);\n        allAnomalies \u003d allAnomalies.concat(anomalies);\n      } else {\n        logError(`Anomalies is not an array for sheet ${sheet.getName()}`);\n      }\n    });\n\n    if (allAnomalies.length \u003e 0) {\n      createErrorReportSheet(allAnomalies);\n      logMessage(`Processed entire spreadsheet. Detected ${allAnomalies.length} anomalies.`);\n      if (isRunningInSpreadsheetContext()) {\n        SpreadsheetApp.getUi().alert(`Processed entire spreadsheet. Detected ${allAnomalies.length} anomalies.`);\n      }\n    } else {\n      logMessage(\u0027No anomalies detected in the entire spreadsheet.\u0027);\n      if (isRunningInSpreadsheetContext()) {\n        SpreadsheetApp.getUi().alert(\u0027No anomalies detected in the entire spreadsheet.\u0027);\n      }\n    }\n  } catch (error) {\n    logError(\u0027Error processing entire spreadsheet: \u0027 + error.message);\n    if (isRunningInSpreadsheetContext()) {\n      SpreadsheetApp.getUi().alert(\u0027Failed to process entire spreadsheet. Please check the logs for more details.\u0027);\n    }\n  }\n}\n\n/**\n * Converts an object to an array if necessary\n * @param {Object} input - The input object to convert.\n * @returns {Array} - The converted array.\n */\nfunction convertToArray(input) {\n  if (Array.isArray(input)) {\n    return input;\n  } else if (typeof input \u003d\u003d\u003d \u0027object\u0027 \u0026\u0026 input !\u003d\u003d null) {\n    if (input.anomalies \u0026\u0026 Array.isArray(input.anomalies)) {\n      return input.anomalies;\n    } else {\n      return Object.values(input);\n    }\n  } else {\n    try {\n      return JSON.parse(input);\n    } catch (error) {\n      logError(\u0027Failed to convert input to array: \u0027 + error.message);\n      return [];\n    }\n  }\n}\n\n/**\n * Function to handle user queries via side-window chat and return GPT responses\n * @param {string} query - The user\u0027s query.\n * @returns {string} - The response from the GPT model.\n */\nfunction handleUserQuery(query) {\n  if (!query || query.trim() \u003d\u003d\u003d \u0027\u0027) {\n    return \u0027Query cannot be empty.\u0027;\n  }\n\n  logMessage(`Handling user query: ${query}`);\n  const sheetData \u003d getSheetData();\n  const gptResponse \u003d sendQueryToGPT(query, sheetData);\n  const processedResponse \u003d processGPTResponse(gptResponse);\n  logMessage(`GPT response processed: ${processedResponse}`);\n  return processedResponse;\n}\n\n/**\n * Generate a report from anomalies in the spreadsheet with options\n * @param {Object} options - The options for customizing the report.\n */\nfunction generateReportWithOptions(options) {\n  try {\n    const spreadsheet \u003d SpreadsheetApp.getActiveSpreadsheet();\n    let errorSheet \u003d spreadsheet.getSheetByName(\u0027Error Report\u0027);\n    let anomalies \u003d [];\n\n    if (!errorSheet) {\n      log(\u0027INFO\u0027, \"\u0027Error Report\u0027 sheet not found. Processing the entire spreadsheet.\");\n      processEntireSpreadsheet();\n      errorSheet \u003d spreadsheet.getSheetByName(\u0027Error Report\u0027);\n    }\n\n    if (errorSheet) {\n      const data \u003d errorSheet.getDataRange().getValues();\n      const headers \u003d data[0];\n      const anomalyRows \u003d data.slice(1);\n\n      anomalies \u003d anomalyRows.map(row \u003d\u003e {\n        return headers.reduce((anomaly, header, index) \u003d\u003e {\n          anomaly[header.toLowerCase()] \u003d row[index];\n          return anomaly;\n        }, {});\n      });\n\n      log(\u0027INFO\u0027, `Using \u0027Error Report\u0027 sheet with ${anomalies.length} anomalies.`);\n    } else {\n      log(\u0027ERROR\u0027, \"\u0027Error Report\u0027 sheet was not created successfully.\");\n      return \u0027Failed to create or find the Error Report sheet.\u0027;\n    }\n\n    if (options.includeAIResults) {\n      const gptResponse \u003d sendQueryToGPT(\u0027Analyze the sheet for anomalies\u0027, getSheetData(), true);\n      const aiAnomalies \u003d processGPTResponse(gptResponse, true);\n      anomalies \u003d anomalies.concat(aiAnomalies);\n    }\n\n    if (Array.isArray(anomalies) \u0026\u0026 anomalies.length \u003e 0) {\n      generateAndOpenReport(anomalies, options);\n      log(\u0027INFO\u0027, \u0027Report generated successfully.\u0027);\n      return \u0027Report generated successfully. Please check the link in the dialog.\u0027;\n    } else {\n      log(\u0027INFO\u0027, \u0027No anomalies found to generate report.\u0027);\n      return \u0027No anomalies found to generate a report.\u0027;\n    }\n  } catch (error) {\n    log(\u0027ERROR\u0027, \u0027Error generating report: \u0027 + error.message);\n    return \u0027Failed to generate report: \u0027 + error.message;\n  }\n}\n\n/**\n * Utility function to get data from the active Google Sheet\n * @returns {Array} - The data from the sheet.\n */\nfunction getSheetData() {\n  try {\n    const sheet \u003d getActiveSheet();\n    return sheet.getDataRange().getValues();\n  } catch (error) {\n    logError(`Error getting sheet data: ${error.message}`);\n    return [];\n  }\n}\n\n/**\n * Utility function to check if the script is running in a spreadsheet context\n * @returns {boolean} - True if running in a spreadsheet context, false otherwise.\n */\nfunction isRunningInSpreadsheetContext() {\n  try {\n    SpreadsheetApp.getUi();\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Utility function to log messages for debugging\n * @param {string} message - The message to log.\n */\nfunction logMessage(message) {\n  Logger.log(`[INFO] [${new Date().toISOString()}] ${message}`);\n}\n\n/**\n * Utility function to log error messages\n * @param {string} errorMessage - The error message to log.\n */\nfunction logError(errorMessage) {\n  Logger.log(`[ERROR] [${new Date().toISOString()}] ${errorMessage}`);\n}"},{"id":"20547dd2-0859-440c-9e29-d15bf0432738","name":"quickbooks","type":"server_js","source":"/**\n * Retrieve QuickBooks environment (default to \u0027SANDBOX\u0027 if not set in Script Properties).\n * @returns {string} - The environment, either \u0027SANDBOX\u0027 or \u0027PRODUCTION\u0027.\n */\nfunction getQuickBooksEnvironment() {\n  const env \u003d PropertiesService.getScriptProperties().getProperty(\u0027QUICKBOOKS_ENV\u0027) || \u0027SANDBOX\u0027;\n  return env.toUpperCase();\n}\n\n/**\n * A map of base URLs by environment for QuickBooks Online.\n */\nconst QUICKBOOKS_BASE_URLS \u003d {\n  SANDBOX: \u0027https://sandbox-quickbooks.api.intuit.com/v3/company/\u0027,\n  PRODUCTION: \u0027https://quickbooks.api.intuit.com/v3/company/\u0027\n};\n\nvar CLIENT_ID \u003d getClientId();\nvar CLIENT_SECRET \u003d getClientSecret();\nvar REDIRECT_URI \u003d getRedirectUri();\nvar BASE_AUTH_URL \u003d \u0027https://appcenter.intuit.com/connect/oauth2\u0027;\nvar TOKEN_URL \u003d \u0027https://oauth.platform.intuit.com/oauth2/v1/tokens/bearer\u0027;\nvar API_SCOPE \u003d \u0027com.intuit.quickbooks.accounting\u0027;\nvar RESPONSE_TYPE \u003d \u0027code\u0027;\n\n/**\n * Validate QuickBooks configuration to ensure all required credentials are present.\n * @returns {boolean} - True if configuration is valid, otherwise false.\n */\nfunction validateQuickBooksConfig() {\n  if (!CLIENT_ID || !CLIENT_SECRET || !REDIRECT_URI) {\n    logError(\u0027QuickBooks configuration is incomplete. Please set CLIENT_ID, CLIENT_SECRET, and REDIRECT_URI.\u0027);\n    return false;\n  }\n  return true;\n}\n\n/**\n * Imports data from QuickBooks using an SQL-like query.\n * @param {string} companyId - The QuickBooks Online company ID.\n * @param {string} query - The SQL-like query for QuickBooks (e.g., SELECT * FROM Invoice).\n * @returns {string} - A message indicating success or the specific error encountered.\n */\nfunction importDataFromQuickBooks(companyId, query) {\n  try {\n    // Validate that the config is present and arguments are not empty\n    if (!validateQuickBooksConfig()) {\n      return \u0027QuickBooks configuration is incomplete. Please configure credentials first.\u0027;\n    }\n    if (!companyId || !query) {\n      logError(`Invalid arguments: companyId\u003d\u0027${companyId}\u0027, query\u003d\u0027${query}\u0027`);\n      return \u0027companyId and query are required fields.\u0027;\n    }\n\n    const environment \u003d getQuickBooksEnvironment();\n    const baseUrl \u003d QUICKBOOKS_BASE_URLS[environment] || QUICKBOOKS_BASE_URLS.SANDBOX;\n\n    const service \u003d getQuickBooksService();\n    if (service.hasAccess()) {\n      // Attempt token refresh if available\n      if (service.canRefresh()) {\n        service.refresh();\n        logMessage(\u0027Token refreshed successfully before API call.\u0027);\n      }\n\n      const url \u003d `${baseUrl}${companyId}/query`;\n      logMessage(`Using QuickBooks Environment: ${environment}`);\n      logMessage(`Importing data from URL: ${url}`);\n\n      const response \u003d UrlFetchApp.fetch(url, {\n        method: \u0027POST\u0027,\n        contentType: \u0027application/text\u0027,\n        payload: query,\n        headers: {\n          Authorization: \u0027Bearer \u0027 + service.getAccessToken(),\n          Accept: \u0027application/json\u0027\n        },\n        muteHttpExceptions: true\n      });\n\n      const responseCode \u003d response.getResponseCode();\n      if (responseCode \u003d\u003d\u003d 200) {\n        const result \u003d JSON.parse(response.getContentText());\n        logMessage(`QuickBooks API call successful. Response: ${JSON.stringify(result, null, 2)}`);\n        return \u0027Data imported successfully!\u0027;\n      } else {\n        // Attempt to parse error from QuickBooks\n        const errorBody \u003d response.getContentText();\n        logError(`QuickBooks API returned error code ${responseCode}. Body: ${errorBody}`);\n        let errorMsg \u003d `Error importing data from QuickBooks: Code ${responseCode}`;\n\n        // Handle 401 specifically (e.g., invalid token or re-auth needed)\n        if (responseCode \u003d\u003d\u003d 401) {\n          errorMsg +\u003d \u0027 - Unauthorized. Please check your token or re-authorize.\u0027;\n        }\n\n        // Attempt to parse JSON response body for more details\n        try {\n          const errorJson \u003d JSON.parse(errorBody);\n          if (errorJson.Fault \u0026\u0026 errorJson.Fault.Error \u0026\u0026 errorJson.Fault.Error[0]) {\n            errorMsg +\u003d ` - ${errorJson.Fault.Error[0].Message}`;\n          }\n        } catch (parseErr) {\n          logError(`Failed to parse error JSON: ${parseErr.message}`);\n        }\n        return errorMsg;\n      }\n    } else {\n      // No valid access token, prompt user for authorization\n      const authorizationUrl \u003d service.getAuthorizationUrl();\n      logMessage(\u0027No valid access token. User must re-authorize.\u0027);\n      return \u0027Authorization required. Open the following URL and re-run the script: \u0027 + authorizationUrl;\n    }\n  } catch (error) {\n    logError(\u0027Error importing data from QuickBooks: \u0027 + error.message);\n    return \u0027Error importing data from QuickBooks: \u0027 + error.message;\n  }\n}\n\n/**\n * Reset the authorization state, so that it can be re-tested.\n */\nfunction resetQuickBooksService() {\n  getQuickBooksService().reset();\n}\n\n/**\n * Configures the QuickBooks service for OAuth2 with Intuit.\n */\nfunction getQuickBooksService() {\n  return OAuth2.createService(\u0027QuickBooks\u0027)\n    .setAuthorizationBaseUrl(BASE_AUTH_URL)\n    .setTokenUrl(TOKEN_URL)\n    .setClientId(CLIENT_ID)\n    .setClientSecret(CLIENT_SECRET)\n    .setScope(API_SCOPE)\n    .setCallbackFunction(\u0027authCallback\u0027)\n    .setParam(\u0027response_type\u0027, RESPONSE_TYPE)\n    .setParam(\u0027state\u0027, getStateToken(\u0027authCallback\u0027)) // Function to generate the state token on the fly\n    .setPropertyStore(PropertiesService.getUserProperties());\n}\n\n/**\n * Handles the OAuth callback from QuickBooks\n */\nfunction authCallback(request) {\n  const service \u003d getQuickBooksService();\n  const authorized \u003d service.handleCallback(request);\n  if (authorized) {\n    logMessage(\u0027Authorization successful.\u0027);\n    return HtmlService.createHtmlOutput(\n      \u0027Authorization successful! You may close this window and return to the spreadsheet.\u0027\n    );\n  } else {\n    logError(\u0027Authorization denied.\u0027);\n    return HtmlService.createHtmlOutput(\u0027Authorization denied.\u0027);\n  }\n}\n\n/**\n * Generate a State Token for OAuth2\n */\nfunction getStateToken(callbackFunction) {\n  return ScriptApp.newStateToken()\n    .withMethod(callbackFunction)\n    .withTimeout(120)\n    .createToken();\n}\n\n/**\n * Logs the redirect URI. Run this function to see the REDIRECT_URI value for your QuickBooks Developer app settings.\n */\nfunction logRedirectUri() {\n  logMessage(getQuickBooksService().getRedirectUri());\n}\n\n/**\n * Get CLIENT_ID from properties\n */\nfunction getClientId() {\n  return PropertiesService.getScriptProperties().getProperty(\u0027CLIENT_ID\u0027);\n}\n\n/**\n * Get CLIENT_SECRET from properties\n */\nfunction getClientSecret() {\n  return PropertiesService.getScriptProperties().getProperty(\u0027CLIENT_SECRET\u0027);\n}\n\n/**\n * Get REDIRECT_URI from properties\n */\nfunction getRedirectUri() {\n  return PropertiesService.getScriptProperties().getProperty(\u0027REDIRECT_URI\u0027);\n}\n\n/**\n * Set configuration values for QuickBooks integration\n * @param {string} clientId - The client ID for QuickBooks API.\n * @param {string} clientSecret - The client secret for QuickBooks API.\n * @param {string} redirectUri - The redirect URI for QuickBooks API.\n */\nfunction setQuickBooksConfig(clientId, clientSecret, redirectUri) {\n  try {\n    PropertiesService.getScriptProperties().setProperty(\u0027CLIENT_ID\u0027, clientId);\n    PropertiesService.getScriptProperties().setProperty(\u0027CLIENT_SECRET\u0027, clientSecret);\n    PropertiesService.getScriptProperties().setProperty(\u0027REDIRECT_URI\u0027, redirectUri);\n    logMessage(\u0027QuickBooks configuration saved successfully.\u0027);\n    return \u0027Configuration saved successfully!\u0027;\n  } catch (error) {\n    logError(\u0027Error saving QuickBooks configuration: \u0027 + error.message);\n    return \u0027Error saving configuration: \u0027 + error.message;\n  }\n}\n\n/**\n * Utility function to log messages for debugging\n * @param {string} message - The message to log.\n */\nfunction logMessage(message) {\n  Logger.log(`[INFO] [${new Date().toISOString()}] ${message}`);\n}\n\n/**\n * Utility function to log error messages\n * @param {string} errorMessage - The error message to log.\n */\nfunction logError(errorMessage) {\n  Logger.log(`[ERROR] [${new Date().toISOString()}] ${errorMessage}`);\n}\n"},{"id":"b98e59e2-65e2-430f-8133-9ad61090d26c","name":"quickbooksConfig","type":"html","source":"\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n\u003chead\u003e\n  \u003cbase target\u003d\"_top\"\u003e\n  \u003cstyle\u003e\n    body {\n      font-family: Arial, sans-serif;\n      padding: 20px;\n      background-color: #f5f5f5;\n    }\n    h3 {\n      color: #4CAF50;\n      margin-bottom: 20px;\n    }\n    .form-group {\n      margin-bottom: 15px;\n    }\n    label {\n      display: flex;\n      align-items: center;\n      margin-bottom: 5px;\n      font-weight: bold;\n    }\n    input[type\u003d\"text\"], textarea {\n      width: 100%;\n      padding: 10px;\n      margin-top: 10px;\n      border: 1px solid #ccc;\n      border-radius: 4px;\n      box-sizing: border-box;\n    }\n    button {\n      background-color: #4CAF50;\n      color: white;\n      border: none;\n      padding: 10px 20px;\n      text-align: center;\n      text-decoration: none;\n      display: inline-block;\n      font-size: 16px;\n      cursor: pointer;\n      border-radius: 4px;\n      margin-top: 10px;\n      transition: background-color 0.3s;\n    }\n    button:hover {\n      background-color: #45a049;\n    }\n    #status {\n      margin-top: 20px;\n      font-weight: bold;\n      color: #333;\n    }\n    .tooltip {\n      position: relative;\n      display: inline-block;\n      border-bottom: 1px dotted black;\n    }\n    .tooltip .tooltiptext {\n      visibility: hidden;\n      width: 220px;\n      background-color: #f9f9f9;\n      color: #000;\n      text-align: center;\n      border-radius: 6px;\n      padding: 5px;\n      border: 1px solid #ddd;\n      position: absolute;\n      z-index: 1;\n      bottom: 100%;\n      left: 50%;\n      margin-left: -110px;\n    }\n    .tooltip:hover .tooltiptext {\n      visibility: visible;\n    }\n  \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n  \u003cdiv\u003e\n    \u003ch3\u003eQuickBooks Configuration\u003c/h3\u003e\n    \u003cdiv class\u003d\"form-group\"\u003e\n      \u003clabel for\u003d\"clientId\"\u003eClient ID:\n        \u003cspan class\u003d\"tooltip\"\u003e?\n          \u003cspan class\u003d\"tooltiptext\"\u003eGet your Client ID from the QuickBooks Developer Portal.\u003cbr\u003e\n            \u003ca href\u003d\"https://developer.intuit.com/app/developer/qbo/docs/get-started\" target\u003d\"_blank\"\u003eLearn more\u003c/a\u003e\n          \u003c/span\u003e\n        \u003c/span\u003e\n      \u003c/label\u003e\n      \u003cinput type\u003d\"text\" id\u003d\"clientId\" placeholder\u003d\"Enter Client ID\"\u003e\n    \u003c/div\u003e\n    \u003cdiv class\u003d\"form-group\"\u003e\n      \u003clabel for\u003d\"clientSecret\"\u003eClient Secret:\n        \u003cspan class\u003d\"tooltip\"\u003e?\n          \u003cspan class\u003d\"tooltiptext\"\u003eGet your Client Secret from the QuickBooks Developer Portal.\u003cbr\u003e\n            \u003ca href\u003d\"https://developer.intuit.com/app/developer/qbo/docs/get-started\" target\u003d\"_blank\"\u003eLearn more\u003c/a\u003e\n          \u003c/span\u003e\n        \u003c/span\u003e\n      \u003c/label\u003e\n      \u003cinput type\u003d\"text\" id\u003d\"clientSecret\" placeholder\u003d\"Enter Client Secret\"\u003e\n    \u003c/div\u003e\n    \u003cdiv class\u003d\"form-group\"\u003e\n      \u003clabel for\u003d\"redirectUri\"\u003eRedirect URI:\n        \u003cspan class\u003d\"tooltip\"\u003e?\n          \u003cspan class\u003d\"tooltiptext\"\u003eSet the Redirect URI in the QuickBooks Developer Portal.\u003cbr\u003e\n            \u003ca href\u003d\"https://developer.intuit.com/app/developer/qbo/docs/get-started\" target\u003d\"_blank\"\u003eLearn more\u003c/a\u003e\n          \u003c/span\u003e\n        \u003c/span\u003e\n      \u003c/label\u003e\n      \u003cinput type\u003d\"text\" id\u003d\"redirectUri\" placeholder\u003d\"Enter Redirect URI\"\u003e\n    \u003c/div\u003e\n    \u003cbutton onclick\u003d\"saveConfig()\"\u003eSave Configuration\u003c/button\u003e\n    \u003cdiv id\u003d\"status\"\u003e\u003c/div\u003e\n  \u003c/div\u003e\n  \u003cdiv\u003e\n    \u003ch3\u003eImport Data from QuickBooks\u003c/h3\u003e\n    \u003cdiv class\u003d\"form-group\"\u003e\n      \u003clabel for\u003d\"companyId\"\u003eCompany ID:\n        \u003cspan class\u003d\"tooltip\"\u003e?\n          \u003cspan class\u003d\"tooltiptext\"\u003eFind your Company ID in your QuickBooks account settings.\u003cbr\u003e\n            \u003ca href\u003d\"https://quickbooks.intuit.com/learn-support/en-us/help-article/customer-company-settings/find-quickbooks-online-company-id/L7lp8O9yU_US_en_US?uid\u003dlwtgscgw\" target\u003d\"_blank\"\u003eLearn more\u003c/a\u003e\n          \u003c/span\u003e\n        \u003c/span\u003e\n      \u003c/label\u003e\n      \u003cinput type\u003d\"text\" id\u003d\"companyId\" placeholder\u003d\"Enter Company ID\"\u003e\n    \u003c/div\u003e\n    \u003cdiv class\u003d\"form-group\"\u003e\n      \u003clabel for\u003d\"query\"\u003eQuery:\n        \u003cspan class\u003d\"tooltip\"\u003e?\n          \u003cspan class\u003d\"tooltiptext\"\u003eEnter the query to fetch data from QuickBooks (SQL-like).\u003cbr\u003e\n            \u003ca href\u003d\"https://developer.intuit.com/app/developer/qbo/docs/api/accounting/all-entities\" target\u003d\"_blank\"\u003eLearn more\u003c/a\u003e\n          \u003c/span\u003e\n        \u003c/span\u003e\n      \u003c/label\u003e\n      \u003ctextarea id\u003d\"query\" rows\u003d\"4\" placeholder\u003d\"Enter Query\"\u003e\u003c/textarea\u003e\n    \u003c/div\u003e\n    \u003cbutton onclick\u003d\"importData()\"\u003eImport Data\u003c/button\u003e\n    \u003cdiv id\u003d\"status\"\u003e\u003c/div\u003e\n  \u003c/div\u003e\n\n  \u003cscript\u003e\n    function saveConfig() {\n      const clientId \u003d document.getElementById(\u0027clientId\u0027).value;\n      const clientSecret \u003d document.getElementById(\u0027clientSecret\u0027).value;\n      const redirectUri \u003d document.getElementById(\u0027redirectUri\u0027).value;\n      clearStatus();\n\n      if (!clientId || !clientSecret || !redirectUri) {\n        displayStatus(\u0027Please enter all configuration details.\u0027, true);\n        return;\n      }\n\n      displayStatus(\u0027Saving configuration...\u0027, false);\n      google.script.run.withSuccessHandler(function(response) {\n        displayStatus(response, false);\n      }).setQuickBooksConfig(clientId, clientSecret, redirectUri);\n    }\n\n    function importData() {\n      const companyId \u003d document.getElementById(\u0027companyId\u0027).value;\n      const query \u003d document.getElementById(\u0027query\u0027).value;\n      clearStatus();\n\n      if (!companyId || !query) {\n        displayStatus(\u0027Please enter both Company ID and Query.\u0027, true);\n        return;\n      }\n\n      displayStatus(\u0027Importing data...\u0027, false);\n      google.script.run.withSuccessHandler(function(response) {\n        displayStatus(response, false);\n      }).importDataFromQuickBooks(companyId, query);\n    }\n\n    function displayStatus(message, isError) {\n      const statusDiv \u003d document.querySelector(\u0027#status\u0027);\n      statusDiv.style.color \u003d isError ? \u0027red\u0027 : \u0027#333\u0027;\n      statusDiv.innerText \u003d message;\n    }\n\n    function clearStatus() {\n      const statusDiv \u003d document.querySelector(\u0027#status\u0027);\n      statusDiv.innerText \u003d \u0027\u0027;\n      statusDiv.style.color \u003d \u0027#333\u0027;\n    }\n  \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e"},{"id":"29dd429c-9f8e-439a-9eb5-a0c34ebc99f8","name":"reportGeneration","type":"server_js","source":"/**\n * Generates a unique report ID (e.g., REPORT-20230801094536).\n */\nfunction generateReportId() {\n  return \u0027REPORT-\u0027 + new Date().toISOString().replace(/[^0-9]/g, \u0027\u0027);\n}\n\n/**\n * Creates a comprehensive Google Doc report from a list of anomalies.\n * \n * Expanded to skip anomalies that are entirely \"N/A\" or zero from counts, charts, and tables.\n * Also includes an optional category breakdown feature.\n *\n * @param {Array} anomalies - The list of anomalies to include.\n * @param {Object} options - Options for customizing the report (sorting, chunking, chart, etc.).\n * @returns {string} - The URL of the created report.\n */\nfunction createReport(anomalies, options) {\n  // If sorting or filtering is requested\n  if (options \u0026\u0026 options.sortBy) {\n    anomalies \u003d sortAnomalies(anomalies, options.sortBy);\n  }\n  if (options \u0026\u0026 options.filterBy) {\n    anomalies \u003d filterAnomalies(anomalies, options.filterBy);\n  }\n\n  // Split large anomaly lists into chunks if needed\n  const chunkSize \u003d (options \u0026\u0026 options.chunkSize) ? options.chunkSize : 500;\n  const chunkedAnomalies \u003d chunkAnomalies(anomalies, chunkSize);\n\n  const reportId \u003d generateReportId();\n  const docName \u003d (options \u0026\u0026 options.docName) ? options.docName : \u0027Transaction Error Report\u0027;\n  const doc \u003d DocumentApp.create(`${docName} - ${reportId}`);\n  const body \u003d doc.getBody();\n\n  addReportTitle(body, options);\n  addReportId(body, reportId);\n  addReportDate(body, options);\n  addIntroduction(body, options);\n\n  // Render anomalies in tables, broken into chunks\n  chunkedAnomalies.forEach((subset, idx) \u003d\u003e {\n    if (chunkedAnomalies.length \u003e 1) {\n      body.appendParagraph(`Anomalies Chunk ${idx + 1}`)\n          .setHeading(DocumentApp.ParagraphHeading.HEADING2)\n          .setBold(true);\n    }\n    addAnomaliesTable(body, subset, options);\n  });\n\n  addSummary(body, anomalies, options);\n  addChart(body, anomalies, options);\n  addDetailedAnalysis(body, anomalies, options);\n  addReportFooter(doc, reportId);\n\n  Logger.log(`Report created with ID: ${reportId}`);\n  return doc.getUrl();\n}\n\n/**\n * Adds a title to the report if requested.\n */\nfunction addReportTitle(body, options) {\n  if (options \u0026\u0026 options.includeTitle) {\n    const title \u003d options.reportTitle || \u0027Transaction Error Report\u0027;\n    body.appendParagraph(title)\n        .setHeading(DocumentApp.ParagraphHeading.TITLE)\n        .setBold(true)\n        .setFontSize(18);\n  }\n}\n\n/**\n * Appends the report ID paragraph.\n */\nfunction addReportId(body, reportId) {\n  body.appendParagraph(`Report ID: ${reportId}`)\n      .setHeading(DocumentApp.ParagraphHeading.HEADING2)\n      .setBold(true);\n}\n\n/**\n * Appends a date/time paragraph, optionally respecting locale.\n */\nfunction addReportDate(body, options) {\n  let dateStr \u003d new Date().toLocaleString();\n  if (options \u0026\u0026 options.locale) {\n    try {\n      dateStr \u003d Utilities.formatDate(new Date(), options.locale, \u0027yyyy-MM-dd HH:mm:ss\u0027);\n    } catch (err) {\n      log(\u0027ERROR\u0027, `Error formatting date with locale (${options.locale}): ${err.message}`);\n    }\n  }\n  body.appendParagraph(`Date: ${dateStr}`)\n      .setHeading(DocumentApp.ParagraphHeading.HEADING2)\n      .setBold(true);\n}\n\n/**\n * Adds an introduction section if requested.\n */\nfunction addIntroduction(body, options) {\n  if (options \u0026\u0026 options.includeIntroduction) {\n    body.appendParagraph(\u0027Introduction\u0027)\n        .setHeading(DocumentApp.ParagraphHeading.HEADING2)\n        .setBold(true);\n\n    const introText \u003d options.introText || (\n      \u0027This report provides a detailed analysis of anomalies in the transactions. \u0027 +\n      \u0027Each anomaly is listed to help identify and correct errors in the data. \u0027 +\n      \u0027Charts and summaries are included to give an overview of the issues and their impact.\u0027\n    );\n    body.appendParagraph(introText);\n  }\n}\n\n/**\n * Builds a table of anomalies. Skips rows that are entirely \"N/A\" or zero.\n */\nfunction addAnomaliesTable(body, anomalies, options) {\n  // Filter out anomalies that contain no real data (i.e., entirely \"N/A\" or zeros).\n  const tableData \u003d anomalies.filter(a \u003d\u003e !onlyHasNAOrZero(a));\n  if (!Array.isArray(tableData) || tableData.length \u003d\u003d\u003d 0) {\n    body.appendParagraph(\u0027No anomalies found for this chunk.\u0027).setBold(true);\n    return;\n  }\n\n  body.appendParagraph(\u0027Anomalies Table\u0027)\n      .setHeading(DocumentApp.ParagraphHeading.HEADING2)\n      .setBold(true);\n\n  const table \u003d body.appendTable();\n  const headers \u003d [\u0027Row\u0027, \u0027Amount\u0027, \u0027Date\u0027, \u0027Description\u0027, \u0027Category\u0027, \u0027Email\u0027, \u0027Errors\u0027];\n  const headerRow \u003d table.appendTableRow();\n  headers.forEach(h \u003d\u003e {\n    headerRow.appendTableCell(h)\n             .setBackgroundColor(\u0027#cccccc\u0027)\n             .setBold(true);\n  });\n\n  tableData.forEach(anomaly \u003d\u003e {\n    const row \u003d table.appendTableRow();\n    const amountStr \u003d (options \u0026\u0026 options.locale \u0026\u0026 typeof anomaly.amount \u003d\u003d\u003d \u0027number\u0027)\n      ? Utilities.formatString(\u0027%s\u0027, anomaly.amount.toLocaleString(options.locale))\n      : (anomaly.amount !\u003d\u003d undefined ? anomaly.amount.toString() : \u0027N/A\u0027);\n\n    const dateStr \u003d (anomaly.date instanceof Date)\n      ? ((options \u0026\u0026 options.locale)\n        ? Utilities.formatDate(anomaly.date, options.locale, \u0027yyyy-MM-dd\u0027)\n        : anomaly.date.toLocaleString())\n      : anomaly.date || \u0027N/A\u0027;\n\n    row.appendTableCell(anomaly.row ? anomaly.row.toString() : \u0027N/A\u0027);\n    row.appendTableCell(amountStr);\n    row.appendTableCell(dateStr);\n    row.appendTableCell(anomaly.description || \u0027N/A\u0027);\n    row.appendTableCell(anomaly.category || \u0027N/A\u0027);\n    row.appendTableCell(anomaly.email || \u0027N/A\u0027);\n    row.appendTableCell(Array.isArray(anomaly.errors) ? anomaly.errors.join(\u0027, \u0027) : \u0027N/A\u0027);\n  });\n}\n\n/**\n * Adds a summary of all anomalies, including numeric analysis and optional category breakdown.\n * Skips anomalies that are entirely \"N/A\" or zero from calculations.\n */\nfunction addSummary(body, anomalies, options) {\n  if (options \u0026\u0026 options.includeSummary) {\n    body.appendParagraph(\u0027Summary\u0027)\n        .setHeading(DocumentApp.ParagraphHeading.HEADING2)\n        .setBold(true);\n\n    // Filter out anomalies that are effectively all \"N/A\" or zero\n    const validAnomalies \u003d anomalies.filter(a \u003d\u003e !onlyHasNAOrZero(a));\n\n    // Basic stats\n    const totalErrors \u003d validAnomalies.length;\n    const uniqueErrorTypes \u003d [...new Set(validAnomalies.flatMap(a \u003d\u003e a.errors))].filter(e \u003d\u003e e \u0026\u0026 e !\u003d\u003d \u0027N/A\u0027).length;\n\n    body.appendParagraph(`Total Errors: ${totalErrors}`).setBold(true);\n    body.appendParagraph(`Unique Error Types: ${uniqueErrorTypes}`).setBold(true);\n\n    // Error breakdown\n    const breakdown \u003d breakdownErrors(validAnomalies);\n    if (Object.keys(breakdown).length \u003e 0) {\n      body.appendParagraph(\u0027Error Breakdown:\u0027);\n      Object.entries(breakdown).forEach(([err, count]) \u003d\u003e {\n        body.appendParagraph(`- ${err}: ${count}`);\n      });\n    }\n\n    // Numeric stats (e.g., amounts)\n    if (options.includeNumericAnalysis) {\n      const numericStats \u003d computeNumericStats(validAnomalies, \u0027amount\u0027);\n      if (numericStats) {\n        body.appendParagraph(\u0027Numeric Analysis of Amounts:\u0027);\n        body.appendParagraph(`- Count (non-N/A): ${numericStats.count}`);\n        body.appendParagraph(`- Sum: ${numericStats.sum}`);\n        body.appendParagraph(`- Average: ${numericStats.average}`);\n        body.appendParagraph(`- Min: ${numericStats.min}`);\n        body.appendParagraph(`- Max: ${numericStats.max}`);\n      }\n    }\n\n    // Optional category breakdown\n    if (options.includeCategoryBreakdown) {\n      const catBreakdown \u003d breakdownCategories(validAnomalies);\n      if (Object.keys(catBreakdown).length \u003e 0) {\n        body.appendParagraph(\u0027Category Breakdown:\u0027);\n        Object.entries(catBreakdown).forEach(([cat, count]) \u003d\u003e {\n          body.appendParagraph(`- ${cat}: ${count}`);\n        });\n      }\n    }\n  }\n}\n\n/**\n * Adds a chart for visual representation of errors, skipping anomalies that are entirely \"N/A\" or zero.\n */\nfunction addChart(body, anomalies, options) {\n  if (options \u0026\u0026 options.includeChart) {\n    body.appendParagraph(\u0027Error Frequency by Type\u0027)\n        .setHeading(DocumentApp.ParagraphHeading.HEADING2)\n        .setBold(true);\n\n    // Filter out any that are all \"N/A\" or zero\n    const validAnomalies \u003d anomalies.filter(a \u003d\u003e !onlyHasNAOrZero(a));\n    const chartBlob \u003d createErrorFrequencyChart(validAnomalies);\n    if (chartBlob) {\n      body.appendImage(chartBlob);\n    } else {\n      body.appendParagraph(\u0027No chart available (no valid anomalies or insufficient data).\u0027);\n    }\n  }\n}\n\n/**\n * Adds a detailed analysis section if requested.\n */\nfunction addDetailedAnalysis(body, anomalies, options) {\n  if (options \u0026\u0026 options.includeDetailedAnalysis) {\n    body.appendParagraph(\u0027Detailed Analysis\u0027)\n        .setHeading(DocumentApp.ParagraphHeading.HEADING2)\n        .setBold(true);\n\n    const text \u003d options.detailedAnalysisText || (\n      \u0027This section provides a deeper look at each anomaly. \u0027 +\n      \u0027The above table outlines row, amount, date, description, category, and errors. \u0027 +\n      \u0027Use this analysis to identify the root causes and correct issues.\u0027\n    );\n    body.appendParagraph(text);\n  }\n}\n\n/**\n * Adds a footer with a clickable link to the doc.\n */\nfunction addReportFooter(doc, reportId) {\n  const footer \u003d doc.addFooter();\n  const reportUrl \u003d doc.getUrl();\n  const reportName \u003d doc.getName();\n\n  footer.appendParagraph(`Report URL: ${reportUrl}`)\n        .setFontSize(10)\n        .setItalic(true);\n\n  const buttonHtml \u003d `\n    \u003cdiv style\u003d\"text-align: center; margin-top: 10px;\"\u003e\n      \u003ca href\u003d\"${reportUrl}\" target\u003d\"_blank\" style\u003d\"\n        background-color: #4CAF50;\n        color: white;\n        border: none;\n        padding: 10px 20px;\n        font-size: 16px;\n        cursor: pointer;\n        border-radius: 4px;\n        text-decoration: none;\n        transition: background-color 0.3s;\n      \"\u003e\n        Open Report: ${reportName}\n      \u003c/a\u003e\n    \u003c/div\u003e\n  `;\n  footer.appendParagraph(buttonHtml).setFontSize(10);\n}\n\n/**\n * Generates and opens the report in a modal dialog UI.\n */\nfunction generateAndOpenReport(anomalies, options) {\n  try {\n    const reportUrl \u003d createReport(anomalies, options);\n    const reportName \u003d (options \u0026\u0026 options.docName) ? options.docName : \u0027Transaction Error Report\u0027;\n    const displayTitle \u003d `${reportName} - ${new Date().toLocaleString()}`;\n\n    const htmlOutput \u003d HtmlService.createHtmlOutput(`\n      \u003cdiv style\u003d\"text-align: center; margin-top: 20px; font-family: Arial, sans-serif;\"\u003e\n        \u003ch3\u003e${displayTitle}\u003c/h3\u003e\n        \u003cp\u003eThe report has been generated successfully. Click below to open and review it.\u003c/p\u003e\n        \u003ca href\u003d\"${reportUrl}\" target\u003d\"_blank\" style\u003d\"\n          background-color: #4CAF50;\n          color: white;\n          border: none;\n          padding: 10px 20px;\n          font-size: 16px;\n          cursor: pointer;\n          border-radius: 4px;\n          text-decoration: none;\n          transition: background-color 0.3s;\n          margin-top: 10px;\n        \"\u003e\n          Open Report\n        \u003c/a\u003e\n        \u003cp style\u003d\"margin-top: 10px;\"\u003eYou can review the anomalies and take necessary actions.\u003c/p\u003e\n      \u003c/div\u003e\n    `);\n    SpreadsheetApp.getUi().showModalDialog(htmlOutput, \u0027Error Report\u0027);\n    log(\u0027INFO\u0027, \u0027Report generated and opened successfully.\u0027);\n  } catch (error) {\n    log(\u0027ERROR\u0027, `Error generating report: ${error.message}`);\n    SpreadsheetApp.getUi().alert(`Failed to generate report: ${error.message}`);\n  }\n}\n\n/**\n * Creates an error frequency chart from anomalies, skipping \"N/A\".\n */\nfunction createErrorFrequencyChart(anomalies) {\n  if (!Array.isArray(anomalies) || anomalies.length \u003d\u003d\u003d 0) {\n    return null;\n  }\n  const errorCounts \u003d anomalies\n    .flatMap(a \u003d\u003e Array.isArray(a.errors) ? a.errors : [a.errors])\n    .filter(e \u003d\u003e e \u0026\u0026 e !\u003d\u003d \u0027N/A\u0027)\n    .reduce((acc, err) \u003d\u003e {\n      acc[err] \u003d (acc[err] || 0) + 1;\n      return acc;\n    }, {});\n\n  if (Object.keys(errorCounts).length \u003d\u003d\u003d 0) {\n    return null;\n  }\n\n  const data \u003d Charts.newDataTable()\n    .addColumn(Charts.ColumnType.STRING, \u0027Error Type\u0027)\n    .addColumn(Charts.ColumnType.NUMBER, \u0027Frequency\u0027);\n\n  Object.entries(errorCounts).forEach(([err, count]) \u003d\u003e {\n    data.addRow([err, count]);\n  });\n\n  const chart \u003d Charts.newBarChart()\n    .setTitle(\u0027Error Frequency by Type\u0027)\n    .setXAxisTitle(\u0027Frequency\u0027)\n    .setYAxisTitle(\u0027Error Type\u0027)\n    .setDimensions(600, 400)\n    .setDataTable(data)\n    .build();\n\n  return chart.getAs(\u0027image/png\u0027);\n}\n\n/**\n * Displays the report generation menu (HTML dialog).\n */\nfunction showReportMenu() {\n  const htmlOutput \u003d HtmlService.createHtmlOutputFromFile(\u0027reportMenu\u0027)\n    .setWidth(500)\n    .setHeight(600);\n  SpreadsheetApp.getUi().showModalDialog(htmlOutput, \u0027Generate Report\u0027);\n}\n\n/**\n * Logs a message or error.\n */\nfunction log(level, message) {\n  const stamp \u003d new Date().toISOString();\n  Logger.log(`[${level}] [${stamp}] ${message}`);\n  if (level \u003d\u003d\u003d \u0027ERROR\u0027) {\n    SpreadsheetApp.getUi().alert(`Error: ${message}`);\n  }\n}\n\n/**\n * Mocks anomaly detection. Stub only.\n */\nfunction detectAnomalies(sheet) {\n  return [];\n}\n\n/**\n * Mocks data retrieval from active sheet. Stub only.\n */\nfunction getSheetData() {\n  return [];\n}\n\n/**\n * Mocks retrieving the active sheet. Stub only.\n */\nfunction getActiveSheet() {\n  return SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();\n}\n\n/**\n * Mocks retrieving or creating a new spreadsheet. Stub only.\n */\nfunction getOrCreateSpreadsheet() {\n  return SpreadsheetApp.getActiveSpreadsheet();\n}\n\n/**\n * Generates a report with certain user-defined options.\n */\nfunction generateReportWithOptions(options) {\n  const spreadsheet \u003d SpreadsheetApp.getActiveSpreadsheet();\n  let errorSheet \u003d spreadsheet.getSheetByName(\u0027Error Report\u0027);\n  let anomalies \u003d [];\n\n  if (!errorSheet) {\n    log(\u0027INFO\u0027, \"\u0027Error Report\u0027 sheet not found. Processing entire spreadsheet.\");\n    processEntireSpreadsheet();\n    errorSheet \u003d spreadsheet.getSheetByName(\u0027Error Report\u0027);\n  }\n\n  if (errorSheet) {\n    const data \u003d errorSheet.getDataRange().getValues();\n    const headers \u003d data[0];\n    const rows \u003d data.slice(1);\n    anomalies \u003d rows.map(r \u003d\u003e {\n      return headers.reduce((obj, h, idx) \u003d\u003e {\n        obj[h.toLowerCase()] \u003d r[idx];\n        return obj;\n      }, {});\n    });\n    log(\u0027INFO\u0027, `Using \u0027Error Report\u0027 sheet with ${anomalies.length} anomalies.`);\n  } else {\n    log(\u0027ERROR\u0027, \"\u0027Error Report\u0027 sheet was not created successfully.\");\n    return \u0027Failed to create or find the Error Report sheet.\u0027;\n  }\n\n  if (options.includeAIResults) {\n    const gptResponse \u003d sendQueryToGPT(\u0027Analyze the sheet for anomalies\u0027, getSheetData(), true);\n    const aiAnomalies \u003d processGPTResponse(gptResponse, true);\n    anomalies \u003d anomalies.concat(aiAnomalies);\n  }\n\n  // Filter out rows that are entirely N/A or zero\n  const validAnomalies \u003d anomalies.filter(a \u003d\u003e !onlyHasNAOrZero(a));\n  if (Array.isArray(validAnomalies) \u0026\u0026 validAnomalies.length \u003e 0) {\n    generateAndOpenReport(validAnomalies, options);\n    log(\u0027INFO\u0027, \u0027Report generated successfully.\u0027);\n    return \u0027Report generated successfully. Please check the link in the dialog.\u0027;\n  } else {\n    log(\u0027INFO\u0027, \u0027No anomalies found to generate report.\u0027);\n    return \u0027No anomalies found to generate a report.\u0027;\n  }\n}\n\n/**\n * Splits anomalies into smaller chunks.\n */\nfunction chunkAnomalies(anomalies, size) {\n  const chunks \u003d [];\n  for (let i \u003d 0; i \u003c anomalies.length; i +\u003d size) {\n    chunks.push(anomalies.slice(i, i + size));\n  }\n  return chunks;\n}\n\n/**\n * Sorts anomalies either by a field or a custom comparator.\n */\nfunction sortAnomalies(anomalies, sortBy) {\n  if (typeof sortBy \u003d\u003d\u003d \u0027function\u0027) {\n    return anomalies.sort(sortBy);\n  }\n  return anomalies.sort((a, b) \u003d\u003e {\n    if (a[sortBy] \u003c b[sortBy]) return -1;\n    if (a[sortBy] \u003e b[sortBy]) return 1;\n    return 0;\n  });\n}\n\n/**\n * Filters anomalies based on a function or a simple condition object.\n */\nfunction filterAnomalies(anomalies, filterBy) {\n  if (typeof filterBy \u003d\u003d\u003d \u0027function\u0027) {\n    return anomalies.filter(filterBy);\n  }\n  if (filterBy \u0026\u0026 filterBy.key \u0026\u0026 filterBy.op \u0026\u0026 filterBy.value !\u003d\u003d undefined) {\n    return anomalies.filter(a \u003d\u003e {\n      const val \u003d a[filterBy.key];\n      switch (filterBy.op) {\n        case \u0027\u003e\u0027: return val \u003e filterBy.value;\n        case \u0027\u003c\u0027: return val \u003c filterBy.value;\n        case \u0027\u003e\u003d\u0027: return val \u003e\u003d filterBy.value;\n        case \u0027\u003c\u003d\u0027: return val \u003c\u003d filterBy.value;\n        case \u0027\u003d\u003d\u0027: return val \u003d\u003d filterBy.value;\n        case \u0027\u003d\u003d\u003d\u0027: return val \u003d\u003d\u003d filterBy.value;\n        default: return true;\n      }\n    });\n  }\n  return anomalies;\n}\n\n/**\n * Counts occurrences of each error type, ignoring \u0027N/A\u0027.\n */\nfunction breakdownErrors(anomalies) {\n  const counts \u003d {};\n  anomalies.forEach(a \u003d\u003e {\n    if (Array.isArray(a.errors)) {\n      a.errors.forEach(err \u003d\u003e {\n        if (err \u0026\u0026 err !\u003d\u003d \u0027N/A\u0027) {\n          counts[err] \u003d (counts[err] || 0) + 1;\n        }\n      });\n    } else if (a.errors \u0026\u0026 a.errors !\u003d\u003d \u0027N/A\u0027) {\n      counts[a.errors] \u003d (counts[a.errors] || 0) + 1;\n    }\n  });\n  return counts;\n}\n\n/**\n * Computes numeric stats for a field, skipping N/A or non-numbers.\n */\nfunction computeNumericStats(anomalies, field) {\n  let sum \u003d 0;\n  let count \u003d 0;\n  let min \u003d Number.POSITIVE_INFINITY;\n  let max \u003d Number.NEGATIVE_INFINITY;\n\n  anomalies.forEach(a \u003d\u003e {\n    const val \u003d a[field];\n    if (typeof val \u003d\u003d\u003d \u0027number\u0027 \u0026\u0026 !isNaN(val)) {\n      sum +\u003d val;\n      if (val \u003c min) min \u003d val;\n      if (val \u003e max) max \u003d val;\n      count++;\n    }\n  });\n\n  if (count \u003d\u003d\u003d 0) return null;\n\n  return {\n    count,\n    sum,\n    average: sum / count,\n    min,\n    max\n  };\n}\n\n/**\n * Determines if an anomaly is effectively all \"N/A\" or zero. \n * Used to skip rows that contain no real data.\n */\nfunction onlyHasNAOrZero(anomaly) {\n  const keys \u003d Object.keys(anomaly);\n  for (let i \u003d 0; i \u003c keys.length; i++) {\n    const val \u003d anomaly[keys[i]];\n    // If there\u0027s a truthy value that isn\u0027t \u0027N/A\u0027 and isn\u0027t 0, we should count it\n    if (\n      val \u0026\u0026\n      val.toString().trim().toUpperCase() !\u003d\u003d \u0027N/A\u0027 \u0026\u0026 \n      !(typeof val \u003d\u003d\u003d \u0027number\u0027 \u0026\u0026 val \u003d\u003d\u003d 0)\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Breaks down anomalies by category, skipping blank or \u0027N/A\u0027.\n */\nfunction breakdownCategories(anomalies) {\n  const counts \u003d {};\n  anomalies.forEach(a \u003d\u003e {\n    const cat \u003d a.category;\n    if (cat \u0026\u0026 cat.toString().trim().toUpperCase() !\u003d\u003d \u0027N/A\u0027) {\n      counts[cat] \u003d (counts[cat] || 0) + 1;\n    }\n  });\n  return counts;\n}\n\n/**\n * Logs an info or error message.\n * (Preserved from original; in some setups, we use logMessage/logError.)\n */\nfunction logMessage(m) {\n  Logger.log(`[INFO] [${new Date().toISOString()}] ${m}`);\n}\nfunction logError(e) {\n  Logger.log(`[ERROR] [${new Date().toISOString()}] ${e}`);\n}\n"},{"id":"3d12c24f-44c4-4803-9e61-7ff2e3b465b8","name":"reportMenu","type":"html","source":"\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n\u003chead\u003e\n  \u003cbase target\u003d\"_top\"\u003e\n  \u003cstyle\u003e\n    body {\n      font-family: Arial, sans-serif;\n      padding: 20px;\n      background-color: #f5f5f5;\n    }\n    h3 {\n      color: #4CAF50;\n      margin-bottom: 20px;\n    }\n    .form-group {\n      margin-bottom: 15px;\n    }\n    label {\n      display: flex;\n      align-items: center;\n      margin-bottom: 5px;\n      font-weight: bold;\n    }\n    input[type\u003d\"checkbox\"] {\n      margin-right: 10px;\n    }\n    button {\n      background-color: #4CAF50;\n      color: white;\n      border: none;\n      padding: 10px 20px;\n      text-align: center;\n      text-decoration: none;\n      display: inline-block;\n      font-size: 16px;\n      cursor: pointer;\n      border-radius: 4px;\n      transition: background-color 0.3s;\n      margin-top: 20px;\n    }\n    button:hover {\n      background-color: #45a049;\n    }\n    .tooltip {\n      position: relative;\n      display: inline-block;\n      border-bottom: 1px dotted black;\n    }\n    .tooltip .tooltiptext {\n      visibility: hidden;\n      width: 220px;\n      background-color: #f9f9f9;\n      color: #000;\n      text-align: center;\n      border-radius: 6px;\n      padding: 5px;\n      border: 1px solid #ddd;\n      position: absolute;\n      z-index: 1;\n      bottom: 125%;\n      left: 50%;\n      margin-left: -110px;\n      opacity: 0;\n      transition: opacity 0.3s;\n    }\n    .tooltip:hover .tooltiptext {\n      visibility: visible;\n      opacity: 1;\n    }\n    #status {\n      margin-top: 20px;\n      font-weight: bold;\n      color: #333;\n    }\n    .spinner {\n      display: none;\n      width: 30px;\n      height: 30px;\n      border: 4px solid rgba(0, 0, 0, 0.1);\n      border-left-color: #4CAF50;\n      border-radius: 50%;\n      animation: spin 1s linear infinite;\n      margin: 20px auto;\n    }\n    @keyframes spin {\n      to {\n        transform: rotate(360deg);\n      }\n    }\n  \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n  \u003cdiv\u003e\n    \u003ch3\u003eGenerate Report\u003c/h3\u003e\n    \u003cform id\u003d\"reportForm\"\u003e\n      \u003cdiv class\u003d\"form-group\"\u003e\n        \u003clabel class\u003d\"tooltip\"\u003e\n          \u003cinput type\u003d\"checkbox\" id\u003d\"includeTitle\" checked\u003e Include Title\n          \u003cspan class\u003d\"tooltiptext\"\u003eInclude a title section at the top of the report.\u003c/span\u003e\n        \u003c/label\u003e\n      \u003c/div\u003e\n      \u003cdiv class\u003d\"form-group\"\u003e\n        \u003clabel class\u003d\"tooltip\"\u003e\n          \u003cinput type\u003d\"checkbox\" id\u003d\"includeIntroduction\" checked\u003e Include Introduction\n          \u003cspan class\u003d\"tooltiptext\"\u003eInclude an introduction section explaining the report.\u003c/span\u003e\n        \u003c/label\u003e\n      \u003c/div\u003e\n      \u003cdiv class\u003d\"form-group\"\u003e\n        \u003clabel class\u003d\"tooltip\"\u003e\n          \u003cinput type\u003d\"checkbox\" id\u003d\"includeSummary\" checked\u003e Include Summary\n          \u003cspan class\u003d\"tooltiptext\"\u003eInclude a summary section with key statistics.\u003c/span\u003e\n        \u003c/label\u003e\n      \u003c/div\u003e\n      \u003cdiv class\u003d\"form-group\"\u003e\n        \u003clabel class\u003d\"tooltip\"\u003e\n          \u003cinput type\u003d\"checkbox\" id\u003d\"includeChart\" checked\u003e Include Chart\n          \u003cspan class\u003d\"tooltiptext\"\u003eInclude a chart visualizing error frequency by type.\u003c/span\u003e\n        \u003c/label\u003e\n      \u003c/div\u003e\n      \u003cdiv class\u003d\"form-group\"\u003e\n        \u003clabel class\u003d\"tooltip\"\u003e\n          \u003cinput type\u003d\"checkbox\" id\u003d\"includeDetailedAnalysis\" checked\u003e Include Detailed Analysis\n          \u003cspan class\u003d\"tooltiptext\"\u003eInclude a detailed analysis of each anomaly detected.\u003c/span\u003e\n        \u003c/label\u003e\n      \u003c/div\u003e\n      \u003cdiv class\u003d\"form-group\"\u003e\n        \u003clabel class\u003d\"tooltip\"\u003e\n          \u003cinput type\u003d\"checkbox\" id\u003d\"includeAI\" checked\u003e Include AI Results\n          \u003cspan class\u003d\"tooltiptext\"\u003eInclude anomalies detected by AI in the report.\u003c/span\u003e\n        \u003c/label\u003e\n      \u003c/div\u003e\n      \u003cbutton type\u003d\"button\" onclick\u003d\"generateReport()\"\u003eGenerate Report\u003c/button\u003e\n      \u003cdiv class\u003d\"spinner\" id\u003d\"spinner\"\u003e\u003c/div\u003e\n    \u003c/form\u003e\n    \u003cdiv id\u003d\"status\"\u003e\u003c/div\u003e\n  \u003c/div\u003e\n  \u003cscript\u003e\n    function generateReport() {\n      const form \u003d document.getElementById(\u0027reportForm\u0027);\n      const options \u003d {\n        includeTitle: form.includeTitle.checked,\n        includeIntroduction: form.includeIntroduction.checked,\n        includeSummary: form.includeSummary.checked,\n        includeChart: form.includeChart.checked,\n        includeDetailedAnalysis: form.includeDetailedAnalysis.checked,\n        includeAIResults: form.includeAI.checked\n      };\n\n      document.getElementById(\u0027status\u0027).innerText \u003d \u0027\u0027;\n      const spinner \u003d document.getElementById(\u0027spinner\u0027);\n      spinner.style.display \u003d \u0027block\u0027;\n\n      google.script.run.withSuccessHandler(function(response) {\n        spinner.style.display \u003d \u0027none\u0027;\n        document.getElementById(\u0027status\u0027).innerText \u003d \u0027Status: \u0027 + response;\n      }).withFailureHandler(function(error) {\n        spinner.style.display \u003d \u0027none\u0027;\n        document.getElementById(\u0027status\u0027).innerText \u003d \u0027Error: \u0027 + error.message;\n      }).generateReportWithOptions(options);\n    }\n  \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e"},{"id":"fb1994cd-3f4a-47d5-b863-b88023704e75","name":"sideWindowChat","type":"server_js","source":"/**\n * Function to create and display the side-window chat interface\n */\nfunction createSideWindowChat() {\n  try {\n    const htmlOutput \u003d HtmlService.createHtmlOutputFromFile(\u0027sideWindowChatScreen\u0027)\n      .setWidth(400)\n      .setHeight(600);\n    SpreadsheetApp.getUi().showSidebar(htmlOutput);\n    logMessage(\u0027Side-window chat interface created successfully.\u0027);\n  } catch (error) {\n    logError(`Error creating side-window chat interface: ${error.message}`);\n  }\n}\n\n/**\n * Function to handle user queries from the side-window\n * @param {string} query - The user\u0027s query.\n * @returns {string} - The response from the GPT model.\n */\nfunction handleUserQuery(query) {\n  try {\n    if (!query) {\n      throw new Error(\u0027Query is empty.\u0027);\n    }\n    logMessage(`Received user query: ${query}`);\n\n    // Optional user-defined logic for special keywords can go here.\n    // For instance, you might detect \"monthly comparison\" or \"yearly analysis\" and redirect.\n\n    const sheetData \u003d getSheetData();\n    const gptResponse \u003d sendQueryToGPT(query, sheetData);\n    const processedResponse \u003d processGPTResponse(gptResponse);\n    logMessage(`Processed GPT response: ${processedResponse}`);\n\n    if (typeof processedResponse \u003d\u003d\u003d \u0027string\u0027) {\n      try {\n        const jsonResponse \u003d JSON.parse(processedResponse);\n        if (jsonResponse.anomalies) {\n          return formatAnomalies(jsonResponse.anomalies);\n        }\n      } catch (e) {\n        return handleSpecialFormatting(processedResponse);\n      }\n    }\n    return processedResponse;\n  } catch (error) {\n    logError(`Error handling user query: ${error.message}`);\n    return `Error handling your query: ${error.message}`;\n  }\n}\n\n/**\n * Format anomalies for better readability\n * @param {Array} anomalies - The list of anomalies to format.\n * @returns {string} - Formatted anomalies as a string.\n */\nfunction formatAnomalies(anomalies) {\n  return anomalies.map(anomaly \u003d\u003e {\n    const rowInfo \u003d anomaly.row ? `Row ${anomaly.row}` : \u0027Unknown Row\u0027;\n    const amountInfo \u003d (anomaly.amount !\u003d\u003d undefined) ? `$${anomaly.amount}` : \u0027N/A\u0027;\n    const dateInfo \u003d anomaly.date ? new Date(anomaly.date).toLocaleDateString() : \u0027N/A\u0027;\n    const descInfo \u003d anomaly.description || \u0027N/A\u0027;\n    const catInfo \u003d anomaly.category || \u0027N/A\u0027;\n    const emailInfo \u003d anomaly.email || \u0027N/A\u0027;\n    const errorsInfo \u003d Array.isArray(anomaly.errors) ? anomaly.errors.join(\u0027, \u0027) : \u0027N/A\u0027;\n    return `\u003cb\u003e${rowInfo}\u003c/b\u003e:\u003cbr\u003e` +\n           `- \u003cb\u003eAmount\u003c/b\u003e: ${amountInfo}\u003cbr\u003e` +\n           `- \u003cb\u003eDate\u003c/b\u003e: ${dateInfo}\u003cbr\u003e` +\n           `- \u003cb\u003eDescription\u003c/b\u003e: ${descInfo}\u003cbr\u003e` +\n           `- \u003cb\u003eCategory\u003c/b\u003e: ${catInfo}\u003cbr\u003e` +\n           `- \u003cb\u003eEmail\u003c/b\u003e: ${emailInfo}\u003cbr\u003e` +\n           `- \u003cb\u003eErrors\u003c/b\u003e: ${errorsInfo}\u003cbr\u003e\u003cbr\u003e`;\n  }).join(\u0027\\n\u0027);\n}\n\n/**\n * Handle special formatting in the response\n * @param {string} response - The response string with potential special formatting.\n * @returns {string} - The formatted response string.\n */\nfunction handleSpecialFormatting(response) {\n  return response\n    .replace(/\\*\\*(.*?)\\*\\*/g, \u0027\u003cb\u003e$1\u003c/b\u003e\u0027)\n    .replace(/\\n/g, \u0027\u003cbr\u003e\u0027);\n}\n\n/**\n * Utility function to get or create a new sheet in Google Drive\n * @returns {Sheet} - The active sheet.\n */\nfunction getOrCreateSheet() {\n  try {\n    const spreadsheet \u003d SpreadsheetApp.getActiveSpreadsheet();\n    let sheet \u003d spreadsheet.getActiveSheet();\n    if (!sheet) {\n      const sheets \u003d spreadsheet.getSheets();\n      if (sheets.length \u003d\u003d\u003d 0) {\n        sheet \u003d spreadsheet.insertSheet(\u0027Sheet1\u0027);\n        logMessage(\u0027Created new sheet: Sheet1\u0027);\n      } else {\n        sheet \u003d sheets[0];\n        logMessage(`Using existing sheet: ${sheet.getName()}`);\n      }\n    } else {\n      logMessage(`Using active sheet: ${sheet.getName()}`);\n    }\n    return sheet;\n  } catch (error) {\n    logError(`Error retrieving or creating sheet: ${error.message}`);\n    throw new Error(\u0027No active sheet found.\u0027);\n  }\n}\n\n/**\n * Utility function to get data from the active Google Sheet\n * @returns {Array} - The data from the sheet.\n */\nfunction getSheetData() {\n  try {\n    const sheet \u003d SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();\n    if (!sheet) {\n      throw new Error(\u0027No active sheet found.\u0027);\n    }\n    const range \u003d sheet.getDataRange();\n    const data \u003d range.getValues();\n    logMessage(`Retrieved data from sheet: ${JSON.stringify(data)}`);\n    return data;\n  } catch (error) {\n    logError(`Error getting sheet data: ${error.message}`);\n    return [];\n  }\n}\n\n/**\n * Utility function to log messages for debugging\n * @param {string} message - The message to log.\n */\nfunction logMessage(message) {\n  Logger.log(`[INFO] [${new Date().toISOString()}] ${message}`);\n}\n\n/**\n * Utility function to log error messages\n * @param {string} errorMessage - The error message to log.\n */\nfunction logError(errorMessage) {\n  Logger.log(`[ERROR] [${new Date().toISOString()}] ${errorMessage}`);\n}\n"},{"id":"2437017d-568e-4967-860c-53183d21a1e7","name":"sideWindowChatScreen","type":"html","source":"\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n\u003chead\u003e\n  \u003cbase target\u003d\"_top\"\u003e\n  \u003cstyle\u003e\n    body {\n      font-family: Arial, sans-serif;\n      padding: 20px;\n      display: flex;\n      flex-direction: column;\n      align-items: center;\n    }\n    h3 {\n      color: #4CAF50;\n      text-align: center;\n    }\n    textarea, input {\n      width: 100%;\n      padding: 10px;\n      margin-top: 10px;\n      border: 1px solid #ccc;\n      border-radius: 4px;\n      box-sizing: border-box;\n    }\n    button {\n      border: none;\n      padding: 10px 20px;\n      text-align: center;\n      text-decoration: none;\n      display: inline-block;\n      font-size: 16px;\n      margin-top: 10px;\n      cursor: pointer;\n      border-radius: 4px;\n      margin-right: 10px;\n      transition: background-color 0.3s;\n    }\n    .send-button {\n      background-color: #4CAF50;\n      color: white;\n    }\n    .send-button:hover {\n      background-color: #45a049;\n    }\n    .clear-button {\n      background-color: #f44336;\n      color: white;\n    }\n    .clear-button:hover {\n      background-color: #e31b0c;\n    }\n    #response {\n      margin-top: 20px;\n      padding: 10px;\n      border: 1px solid #ccc;\n      border-radius: 4px;\n      background-color: #f9f9f9;\n      white-space: pre-wrap; /* Preserve whitespace formatting */\n      max-height: 300px;\n      overflow-y: auto;\n      width: 100%;\n    }\n    #error {\n      color: red;\n      margin-top: 10px;\n    }\n    .tooltip {\n      position: relative;\n      display: inline-block;\n      border-bottom: 1px dotted black;\n    }\n    .tooltip .tooltiptext {\n      visibility: hidden;\n      width: 220px;\n      background-color: #f9f9f9;\n      color: #000;\n      text-align: center;\n      border-radius: 6px;\n      padding: 5px;\n      border: 1px solid #ddd;\n      position: absolute;\n      z-index: 1;\n      bottom: 100%;\n      left: 50%;\n      margin-left: -110px;\n    }\n    .tooltip:hover .tooltiptext {\n      visibility: visible;\n    }\n    .buttons {\n      display: flex;\n      justify-content: flex-start;\n    }\n    .common-requests {\n      margin-top: 20px;\n      width: 100%;\n    }\n    .bold {\n      font-weight: bold;\n    }\n    .json-key {\n      color: #d14;\n    }\n    .json-value {\n      color: #1a1aa6;\n    }\n    .json-string {\n      color: #d14;\n    }\n    .json-number {\n      color: #1a1aa6;\n    }\n    .json-boolean {\n      color: #1a1aa6;\n    }\n    .json-null {\n      color: #1a1aa6;\n    }\n    .container {\n      max-width: 800px;\n      width: 100%;\n    }\n    .logo-container {\n      display: flex;\n      justify-content: center;\n      margin-bottom: 20px;\n    }\n    .logo {\n      max-height: 128px;\n      height: auto;\n    }\n  \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n  \u003cdiv class\u003d\"container\"\u003e\n    \u003cdiv class\u003d\"logo-container\"\u003e\n      \u003cimg src\u003d\"https://ascentio.net/wp-content/uploads/2024/05/FE_Logo_app.png\" alt\u003d\"Logo\" class\u003d\"logo\"\u003e\n    \u003c/div\u003e\n    \u003ch3\u003eFiscal Eye Chat\u003c/h3\u003e\n    \u003clabel for\u003d\"query\"\u003eEnter your query:\n      \u003cspan class\u003d\"tooltip\"\u003e?\n        \u003cspan class\u003d\"tooltiptext\"\u003eYou can ask for transaction analysis, anomaly detection, and more.\u003cbr\u003e\n          \u003ca href\u003d\"https://example.com/docs\" target\u003d\"_blank\"\u003eLearn more\u003c/a\u003e\n        \u003c/span\u003e\n      \u003c/span\u003e\n    \u003c/label\u003e\n    \u003ctextarea id\u003d\"query\" rows\u003d\"4\" placeholder\u003d\"Enter your query here...\"\u003e\u003c/textarea\u003e\u003cbr\u003e\n    \u003cdiv class\u003d\"buttons\"\u003e\n      \u003cbutton class\u003d\"send-button\" onclick\u003d\"sendQuery()\"\u003eSend\u003c/button\u003e\n      \u003cbutton class\u003d\"clear-button\" onclick\u003d\"clearQuery()\"\u003eClear\u003c/button\u003e\n    \u003c/div\u003e\n    \u003cdiv id\u003d\"response\"\u003e\u003c/div\u003e\n    \u003cdiv id\u003d\"error\"\u003e\u003c/div\u003e\n    \u003cdiv class\u003d\"common-requests\"\u003e\n      \u003ch3\u003eCommon Requests\u003c/h3\u003e\n      \u003cbutton onclick\u003d\"monthlyComparison()\"\u003eMonthly Comparison\u003c/button\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n  \u003cscript\u003e\n    function sendQuery() {\n      const query \u003d document.getElementById(\u0027query\u0027).value;\n      if (!query.trim()) {\n        displayError(\u0027Query cannot be empty.\u0027);\n        return;\n      }\n      clearError();\n      displayResponse(\u0027Processing...\u0027);\n      google.script.run.withSuccessHandler(displayResponse).withFailureHandler(displayError).handleUserQuery(query);\n    }\n\n    function clearQuery() {\n      document.getElementById(\u0027query\u0027).value \u003d \u0027\u0027;\n      document.getElementById(\u0027response\u0027).innerText \u003d \u0027\u0027;\n      clearError();\n    }\n\n    function displayResponse(response) {\n      // Attempt to detect JSON and highlight if valid\n      if (isJSONString(response)) {\n        const jsonResponse \u003d JSON.parse(response);\n        document.getElementById(\u0027response\u0027).innerHTML \u003d syntaxHighlight(jsonResponse);\n      } else {\n        // Replace ** with \u003cspan class\u003d\"bold\"\u003e for bold text\n        const formattedResponse \u003d response.replace(/\\*\\*(.*?)\\*\\*/g, \u0027\u003cspan class\u003d\"bold\"\u003e$1\u003c/span\u003e\u0027);\n        document.getElementById(\u0027response\u0027).innerHTML \u003d formattedResponse;\n      }\n    }\n\n    function displayError(error) {\n      document.getElementById(\u0027error\u0027).innerText \u003d `Error: ${error}`;\n    }\n\n    function clearError() {\n      document.getElementById(\u0027error\u0027).innerText \u003d \u0027\u0027;\n    }\n\n    function monthlyComparison() {\n      const query \u003d \u0027monthly comparison\u0027;\n      document.getElementById(\u0027query\u0027).value \u003d query;\n      sendQuery();\n    }\n\n    function isJSONString(str) {\n      try {\n        JSON.parse(str);\n      } catch (e) {\n        return false;\n      }\n      return true;\n    }\n\n    function syntaxHighlight(json) {\n      if (typeof json !\u003d\u003d \u0027string\u0027) {\n        json \u003d JSON.stringify(json, undefined, 2);\n      }\n      json \u003d json.replace(/\u0026/g, \u0027\u0026amp;\u0027).replace(/\u003c/g, \u0027\u0026lt;\u0027).replace(/\u003e/g, \u0027\u0026gt;\u0027);\n      return json.replace(/(\\\"(\\\\u[a-zA-Z0-9]{4}|\\\\[^u]|[^\\\\\\\"])*\\\"(\\\\s*:)?|\\\\b(true|false|null)\\\\b|-?\\\\d+(?:\\\\.\\\\d*)?(?:[eE][+\\\\-]?\\\\d+)?)/g, function (match) {\n        let cls \u003d \u0027json-number\u0027;\n        if (/^\\\"/.test(match)) {\n          if (/:$/.test(match)) {\n            cls \u003d \u0027json-key\u0027;\n          } else {\n            cls \u003d \u0027json-string\u0027;\n          }\n        } else if (/true|false/.test(match)) {\n          cls \u003d \u0027json-boolean\u0027;\n        } else if (/null/.test(match)) {\n          cls \u003d \u0027json-null\u0027;\n        }\n        return \u0027\u003cspan class\u003d\"\u0027 + cls + \u0027\"\u003e\u0027 + match + \u0027\u003c/span\u003e\u0027;\n      });\n    }\n  \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},{"id":"da581038-efb8-452c-927a-639882c147f7","name":"utilities","type":"server_js","source":"/**\n * Utilities for formatting cells, managing sheets, and logging.\n * This file provides centralized functions that can be called across scripts\n * to maintain consistency and reduce duplication.\n */\n\n/**\n * Formats a range of cells with a specified background color.\n * @param {Range} range - The range of cells to format.\n * @param {string} backgroundColor - The background color to set.\n */\nfunction formatCells(range, backgroundColor) {\n  try {\n    if (!range) {\n      logError(\u0027Cannot format cells: Range is null or undefined.\u0027);\n      return;\n    }\n    range.setBackground(backgroundColor);\n    logMessage(`Formatted range ${range.getA1Notation()} with color ${backgroundColor}`);\n  } catch (error) {\n    logError(`Error formatting cells: ${error.message}`);\n  }\n}\n\n/**\n * Creates or replaces a sheet with a specified name, deleting any existing sheet first.\n * @param {Spreadsheet} spreadsheet - The spreadsheet object.\n * @param {string} sheetName - The name of the sheet to create or replace.\n * @returns {Sheet} - The created or replaced sheet.\n */\nfunction createOrReplaceSheet(spreadsheet, sheetName) {\n  try {\n    let sheet \u003d spreadsheet.getSheetByName(sheetName);\n    if (sheet) {\n      spreadsheet.deleteSheet(sheet);\n      logMessage(`Deleted existing sheet: ${sheetName}`);\n    }\n    sheet \u003d spreadsheet.insertSheet(sheetName);\n    logMessage(`Created new sheet: ${sheetName}`);\n    return sheet;\n  } catch (error) {\n    logError(`Error creating or replacing sheet: ${error.message}`);\n    throw new Error(`Failed to create or replace sheet: ${sheetName}`);\n  }\n}\n\n/**\n * Appends a row of data to a specified sheet.\n * @param {Sheet} sheet - The sheet to append the row to.\n * @param {Array} rowData - The data to append as a row.\n */\nfunction appendRowToSheet(sheet, rowData) {\n  try {\n    if (!sheet) {\n      throw new Error(\u0027Sheet is undefined.\u0027);\n    }\n    sheet.appendRow(rowData);\n    logMessage(`Appended row to sheet ${sheet.getName()}: ${JSON.stringify(rowData)}`);\n  } catch (error) {\n    logError(`Error appending row to sheet: ${error.message}`);\n    throw new Error(`Failed to append row to sheet: ${sheet ? sheet.getName() : \u0027undefined\u0027}`);\n  }\n}\n\n/**\n * Clears the contents of a sheet.\n * @param {Sheet} sheet - The sheet to clear.\n */\nfunction clearSheet(sheet) {\n  try {\n    if (!sheet) {\n      throw new Error(\u0027Sheet is undefined.\u0027);\n    }\n    sheet.clear();\n    logMessage(`Cleared contents of sheet: ${sheet.getName()}`);\n  } catch (error) {\n    logError(`Error clearing sheet: ${error.message}`);\n  }\n}\n\n/**\n * Sets values in a range of cells.\n * @param {Range} range - The range to set values in.\n * @param {Array} values - The values to set in the range.\n */\nfunction setValues(range, values) {\n  try {\n    if (!range) {\n      throw new Error(\u0027Range is undefined.\u0027);\n    }\n    range.setValues(values);\n    logMessage(`Set values in range ${range.getA1Notation()}: ${JSON.stringify(values)}`);\n  } catch (error) {\n    logError(`Error setting values in range: ${error.message}`);\n  }\n}\n\n/**\n * Gets values from a range of cells.\n * @param {Range} range - The range to get values from.\n * @returns {Array} - The values in the range.\n */\nfunction getValues(range) {\n  try {\n    if (!range) {\n      throw new Error(\u0027Range is undefined.\u0027);\n    }\n    const values \u003d range.getValues();\n    logMessage(`Retrieved values from range ${range.getA1Notation()}: ${JSON.stringify(values)}`);\n    return values;\n  } catch (error) {\n    logError(`Error getting values from range: ${error.message}`);\n    return [];\n  }\n}\n\n/**\n * Creates a new spreadsheet in Google Drive.\n * @param {string} name - The name of the new spreadsheet.\n * @returns {Spreadsheet} - The created spreadsheet.\n */\nfunction createNewSpreadsheet(name) {\n  try {\n    const file \u003d DriveApp.createFile(name, \u0027\u0027, MimeType.GOOGLE_SHEETS);\n    const spreadsheet \u003d SpreadsheetApp.openById(file.getId());\n    logMessage(`Created a new spreadsheet in Google Drive: ${name}`);\n    return spreadsheet;\n  } catch (error) {\n    logError(`Error creating new spreadsheet: ${error.message}`);\n    throw new Error(`Failed to create new spreadsheet: ${name}`);\n  }\n}\n\n/**\n * Retrieves or creates a sheet with a specified name.\n * @param {Spreadsheet} spreadsheet - The spreadsheet object.\n * @param {string} sheetName - The name of the sheet to retrieve or create.\n * @returns {Sheet} - The retrieved or created sheet.\n */\nfunction getOrCreateSheetByName(spreadsheet, sheetName) {\n  try {\n    let sheet \u003d spreadsheet.getSheetByName(sheetName);\n    if (!sheet) {\n      sheet \u003d spreadsheet.insertSheet(sheetName);\n      logMessage(`Created new sheet: ${sheetName}`);\n    } else {\n      logMessage(`Retrieved existing sheet: ${sheetName}`);\n    }\n    return sheet;\n  } catch (error) {\n    logError(`Error retrieving or creating sheet: ${error.message}`);\n    throw new Error(`Failed to retrieve or create sheet: ${sheetName}`);\n  }\n}\n\n/**\n * Deletes a sheet by name if it exists.\n * @param {Spreadsheet} spreadsheet - The spreadsheet object.\n * @param {string} sheetName - The name of the sheet to delete.\n */\nfunction deleteSheetByName(spreadsheet, sheetName) {\n  try {\n    const sheet \u003d spreadsheet.getSheetByName(sheetName);\n    if (sheet) {\n      spreadsheet.deleteSheet(sheet);\n      logMessage(`Deleted sheet: ${sheetName}`);\n    } else {\n      logMessage(`Sheet not found: ${sheetName}`);\n    }\n  } catch (error) {\n    logError(`Error deleting sheet: ${error.message}`);\n    throw new Error(`Failed to delete sheet: ${sheetName}`);\n  }\n}\n\n/**\n * Moves a sheet to a new position within the spreadsheet.\n * @param {Sheet} sheet - The sheet to move.\n * @param {number} position - The new position for the sheet.\n */\nfunction moveSheet(sheet, position) {\n  try {\n    if (!sheet) {\n      throw new Error(\u0027Sheet is undefined.\u0027);\n    }\n    sheet.activate();\n    const spreadsheet \u003d sheet.getParent();\n    spreadsheet.setActiveSheet(sheet);\n    spreadsheet.moveActiveSheet(position);\n    logMessage(`Moved sheet ${sheet.getName()} to position ${position}`);\n  } catch (error) {\n    logError(`Error moving sheet: ${error.message}`);\n    throw new Error(`Failed to move sheet: ${sheet ? sheet.getName() : \u0027undefined\u0027} to position: ${position}`);\n  }\n}\n\n/**\n * Renames a sheet if it exists.\n * @param {Spreadsheet} spreadsheet - The parent spreadsheet.\n * @param {string} oldName - The current name of the sheet.\n * @param {string} newName - The new name for the sheet.\n */\nfunction renameSheet(spreadsheet, oldName, newName) {\n  try {\n    const sheet \u003d spreadsheet.getSheetByName(oldName);\n    if (!sheet) {\n      logError(`Sheet \u0027${oldName}\u0027 not found. Cannot rename.`);\n      return;\n    }\n    sheet.setName(newName);\n    logMessage(`Renamed sheet from \u0027${oldName}\u0027 to \u0027${newName}\u0027.`);\n  } catch (error) {\n    logError(`Error renaming sheet \u0027${oldName}\u0027 to \u0027${newName}\u0027: ${error.message}`);\n  }\n}\n\n/**\n * Checks if a sheet is empty (no content beyond headers, or no rows).\n * @param {Sheet} sheet - The sheet to check.\n * @returns {boolean} - True if the sheet has no meaningful data rows, false otherwise.\n */\nfunction isSheetEmpty(sheet) {\n  try {\n    if (!sheet) {\n      throw new Error(\u0027Sheet is undefined.\u0027);\n    }\n    const lastRow \u003d sheet.getLastRow();\n    // If only 1 row or 0, it means it\u0027s either all headers or blank\n    if (lastRow \u003c 2) {\n      return true;\n    }\n    // Could do additional checks for blank cells if needed\n    return false;\n  } catch (error) {\n    logError(`Error checking if sheet is empty: ${error.message}`);\n    return false;\n  }\n}\n\n/**\n * Validates a cell value using a user-defined validator function.\n * @param {Range} range - The cell range to validate (should be a single cell range).\n * @param {Function} validator - A function that takes a cell value and returns a boolean.\n * @returns {boolean} - True if validation passes, false otherwise.\n */\nfunction validateCellValue(range, validator) {\n  try {\n    if (!range) {\n      throw new Error(\u0027Range is undefined.\u0027);\n    }\n    if (range.getNumRows() !\u003d\u003d 1 || range.getNumColumns() !\u003d\u003d 1) {\n      throw new Error(\u0027validateCellValue expects a single cell range.\u0027);\n    }\n    const value \u003d range.getValue();\n    const isValid \u003d validator(value);\n    logMessage(`Validation of cell \u0027${range.getA1Notation()}\u0027 returned: ${isValid}`);\n    return isValid;\n  } catch (error) {\n    logError(`Error validating cell value: ${error.message}`);\n    return false;\n  }\n}\n\n/**\n * Utility function to log messages for debugging.\n * @param {string} message - The message to log.\n */\nfunction logMessage(message) {\n  Logger.log(`[INFO] [${new Date().toISOString()}] ${message}`);\n}\n\n/**\n * Utility function to log error messages.\n * @param {string} errorMessage - The error message to log.\n */\nfunction logError(errorMessage) {\n  Logger.log(`[ERROR] [${new Date().toISOString()}] ${errorMessage}`);\n}\n"}]}